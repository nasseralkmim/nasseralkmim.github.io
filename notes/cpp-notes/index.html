<!DOCTYPE html>
<html lang="en-us">

<head>
  <title>C&#43;&#43; Notes | Nasser&#39;s personal website</title>

  <meta charset="UTF-8">
  <meta name="language" content="en">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  
  

  <link rel="shortcut icon" type="image/png" href="/favicon.ico" />


  
  
    
 
  
  
  
  
  
  
    
    <link type="text/css" rel="stylesheet" href="/css/post.min.980e2950259a4c9758e043cba33eed844bfa8ee1e25ce4cb0e96527f05f70bf7.css" integrity="sha256-mA4pUCWaTJdY4EPLoz7thEv6juHiXOTLDpZSfwX3C/c="/>
  
    
    <link type="text/css" rel="stylesheet" href="/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css" integrity="sha256-47DEQpj8HBSa&#43;/TImW&#43;5JCeuQeRkm5NMpJWZG3hSuFU="/>
  
  
   
   
    

<script type="application/ld+json">
  
    { 
      "@context": "http://schema.org", 
      "@type": "WebSite", 
      "url": "https:\/\/nasseralkmim.github.io\/notes\/cpp-notes\/",
      "name": "C\u002b\u002b Notes",
      "author": {
        "@type": "Person",
        "name": ""
      },
      "description": ""
    }
  
  </script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-74704246-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</head>

<body>
  <div class="burger__container">
  <div class="burger" aria-controls="navigation" aria-label="Menu">
    <div class="burger__meat burger__meat--1"></div>
    <div class="burger__meat burger__meat--2"></div>
    <div class="burger__meat burger__meat--3"></div>
  </div>
</div>
 

  <nav class="nav" id="navigation">
  <ul class="nav__list">
    
    
      <li>
        <a  href="/">home</a>
      </li>
    
      <li>
        <a  class="active"
         href="/notes">notes</a>
      </li>
    
  </ul>
</nav>


  <main>
    
    

    <div class="flex-wrapper">
      <div class="post__container">
        <div class="post">
          <header class="post__header">
            <h1 id="post__title">C&#43;&#43; Notes</h1>
            <time datetime="2021-04-02 00:00:00 &#43;0000 UTC" class="post__date">Apr 2 2021</time> 
          </header>
          <article class="post__content">
              

<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Introduction
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>
These are my notes about C++.
Mostly experiments and running examples with <code class="verbatim">org-babel</code> within Emacs.</p>
<p>
Ideally, if you want to benefit from this, you should write, run, and understand the examples yourself.</p>
<p>
If you don&#39;t know about <code class="verbatim">org-mode</code> with <code class="verbatim">org-babel</code>, it is an Emacs package that allows prose and code execution (multiple languages) within the same file.
It is extremely powerful and useful as a learning tool and also to create literate programming narratives or prototypes.</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
Advice
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
General
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<ol>
<li>
<p>state <strong>intent</strong> in comments, don&#39;t say what can be stated in code</p>
<ol>
<li>
<p>what is the intention behind this block of code? <strong>why</strong> are you doing? the code itself describes thew <strong>how</strong> you are doing</p>
</li>
<li>
<p>via negative: don&#39;t describe your code </p>
</li>
</ol>
</li>
<li>
<p>don&#39;t declare variable until you have a value to initialize it with (same reason as 5)</p>
<ol>
<li>
<p>avoid crashes and wrong outputs by &#34;access through uninitialized pointers and out-of-range access&#34;</p>
</li>
</ol>
</li>
<li>
<p>avoid uninitialized variables</p>
<ol>
<li>
<p>because if we try to use the variable before it was initialized the compiler would give an undefined behavior</p>
</li>
<li>
<p>initialize means assign a value</p>
</li>
<li>
<p>the construct ensures that every object of a class is initialized</p>
</li>
<li>
<p><a href="*Type safety">Type safety</a></p>
</li>
</ol>
</li>
<li>
<p>avoid narrowing conversions (?)</p>
<ol>
<li>
<p>conversion of types (?)</p>
</li>
</ol>
</li>
<li>
<p>function should be short and perform one task</p>
</li>
<li>
<p>one name per declaration (?)</p>
</li>
<li>
<p>avoid magic constants, use symbolic constants (?)</p>
</li>
<li>
<p><code class="verbatim">{}</code> for initializer an object with values and lists</p>
<ol>
<li>
<p><em>indicates construction</em> and avoid confusion with function arguments.</p>
</li>
<li>
<p>instead of <code class="verbatim">()</code> for function call and <code class="verbatim">[]</code> which indicates array.</p>
</li>
<li>
<p>exceptions common because of old habits: simple initialization with <code class="verbatim">=</code> and <code class="verbatim">()</code> for number of elements in vectors.</p>
<ol>
<li>
<p><code class="verbatim">=</code> was kept from C language, but it confuses with an assignment</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>public interface and implementation of a class should be separated</p>
</li>
<li>
<p>avoid over use of parenthesis</p>
</li>
<li>
<p>balance between obscure trickery and boring prolixity</p>
</li>
<li>
<p>avoid <code class="verbatim">new</code> outside constructor</p>
<ol>
<li>
<p>avoid memory leak if forget to delete the <code class="verbatim">new</code> created</p>
</li>
<li>
<p><code class="verbatim">delete</code> inside destructors</p>
</li>
</ol>
</li>
<li>
<p>avoid implicit conversion withing a class constructor</p>
<ol>
<li>
<p>better use the <code class="verbatim">explicit</code> when initializing with single argument</p>
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-4" class="outline-3">
<h3 id="headline-4">
Programming practices
</h3>
<div id="outline-text-headline-4" class="outline-text-3">
<ol>
<li>
<p>approach a task with gradual refinement</p>
<ol>
<li>
<p>constantly test enhancements</p>
</li>
</ol>
</li>
<li>
<p>&#34;compile&#34; does not mean works correctly</p>
</li>
<li>
<p>avoid unnecessary copying by passing vectors and matrices by reference</p>
</li>
<li>
<p>always use <code class="verbatim">const</code> to protect unintended data modification</p>
</li>
<li>
<p>limit to few data types, <code class="verbatim">int</code> and <code class="verbatim">double</code> for instance</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-5" class="outline-3">
<h3 id="headline-5">
Naming conventions
</h3>
<div id="outline-text-headline-5" class="outline-text-3">
<ol>
<li>
<p>UserDefinedTypes</p>
</li>
<li>
<p>variable_names</p>
</li>
<li>
<p>class_data_members_</p>
</li>
<li>
<p>struct_data</p>
</li>
<li>
<p>kConstantVariables</p>
</li>
<li>
<p>FunctionNames</p>
</li>
<li>
<p>namespaces_names</p>
</li>
<li>
<p>avoid ALL_CAPS</p>
</li>
<li>
<p>common and local names short and nonlocal longer</p>
</li>
<li>
<p>avoid long member functions definitions (bodies) inside classes declarations</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
Technicalities
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Declarations and definitions
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>Declaration <span style="text-decoration: underline;">introduces a name</span> into a scope.
It is different from <strong>defining</strong> something.
A <span style="text-decoration: underline;">declaration that specifies</span> the entity is a <strong>definition</strong>.</p>
<p>
<strong>Before a name can be used it must be declared.</strong></p>
<p>
Declarations specify type and, optionally, an initializer (initial value).
It defines how something can be used, when not interested in implementation details.
Declarations do not consume memory, whereas definitions do.
This is why C++ uses it, for efficiency purposes.</p>
<p>
<strong>Declarations must be consistent.</strong>
A declared function can not return double and int.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> a = <span style="color:#00d;font-weight:bold">1</span>;			<span style="color:#888">// a is the name of this declaration, 1 is the initial value
</span><span style="color:#888"></span>}</code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
Headers
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>
It is a file, <code class="verbatim">.h</code>, that helps us to manage <span style="text-decoration: underline;">declarations</span> of facilities defined elsewhere.
Those files are included with <code class="verbatim">#include</code>.</p>
<p>
The <span style="text-decoration: underline;">definition</span>, usually, is written elsewhere.
The uses also are usually written in another file.</p>
<p>
If we want to use a function that was defined in <code class="verbatim">widget.cpp</code> in <code class="verbatim">main.cpp</code> we need to <code class="verbatim">#include widget.h</code>, which is the header file with the <span style="text-decoration: underline;">declaration</span>.</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
Namespace
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<p>
Allow us to identify part of a program without defining a type.
A name is composed by the namespace name and a member name combined with <code class="verbatim">::</code>, this is a fully qualified name.
With <code class="verbatim">namespace</code> we can group named entities, useful to narrow scope of naming.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">namespace</span> identifier {
<span style="color:#888;font-weight:bold">int</span> a = <span style="color:#00d;font-weight:bold">10</span>; <span style="color:#888">// name &#34;a&#34; is narrowed in scope by the identifier
</span><span style="color:#888"></span>} <span style="color:#888">// namespace identifier
</span><span style="color:#888"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() { std::cout &lt;&lt; identifier::a; }</code></pre></div>
</div>
<pre class="example">
10
</pre>
<p>
A shorthand can be used to avoid typing the namespace name every time with <code class="verbatim">using namespace &#34;name&#34;</code>.
This way the name becomes directly available for use.</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-3">
<h3 id="headline-10">
Operators
</h3>
<div id="outline-text-headline-10" class="outline-text-3">
<div id="outline-container-headline-11" class="outline-4">
<h4 id="headline-11">
Logical operators (!, &amp;&amp;, ||)
</h4>
<div id="outline-text-headline-11" class="outline-text-4">
<p>
<code class="verbatim">!</code> boolean for NOT.
If its operand on its right is true, <code class="verbatim">!</code> turns it into false.</p>
<p>
<code class="verbatim">&amp;&amp;</code> means AND and <code class="verbatim">||</code> means OR.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#080;font-weight:bold">if</span> (!<span style="color:#038">false</span>) {cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;ok&#34;</span>;}
}</code></pre></div>
</div>
<pre class="example">
ok
</pre>
</div>
</div>
<div id="outline-container-headline-12" class="outline-4">
<h4 id="headline-12">
Compound assignments (+=, *=)
</h4>
<div id="outline-text-headline-12" class="outline-text-4">
<p>
Modify current value of variable.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> a, b = <span style="color:#00d;font-weight:bold">3</span>; <span style="color:#888">// b is initialized with a value 3
</span><span style="color:#888"></span>  a = b;        <span style="color:#888">// assign b value to a
</span><span style="color:#888"></span>  a += <span style="color:#00d;font-weight:bold">2</span>;       <span style="color:#888">// equivalent to a=a+2
</span><span style="color:#888"></span>  cout &lt;&lt; a;
}</code></pre></div>
</div>
<pre class="example">
5
</pre>
</div>
</div>
<div id="outline-container-headline-13" class="outline-4">
<h4 id="headline-13">
Member access operators (., -&gt;)
</h4>
<div id="outline-text-headline-13" class="outline-text-4">
<p>
Use <code class="verbatim">.</code> to access a member of a class.
Use <code class="verbatim">-&gt;</code> to access a member through a pointer.</p>
<p>
See <a href="*Accessing elements">Accessing elements</a> for example.</p>
</div>
</div>
<div id="outline-container-headline-14" class="outline-4">
<h4 id="headline-14">
Conditional ternary (?)
</h4>
<div id="outline-text-headline-14" class="outline-text-4">
<p>
Conditional operator <code class="verbatim">?</code> evaluates an expression, returning first value if true and second if false.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> a, b, c;

  a = <span style="color:#00d;font-weight:bold">2</span>;
  b = <span style="color:#00d;font-weight:bold">7</span>;
  c = (a &gt; b) ? <span style="color:#369;font-style:italic">a</span> : b; <span style="color:#888">// false, so return return b, then c=7
</span><span style="color:#888"></span>
  cout &lt;&lt; c &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#39;\n&#39;</span>;
}</code></pre></div>
</div>
<pre class="example">
7
</pre>
</div>
</div>
<div id="outline-container-headline-15" class="outline-4">
<h4 id="headline-15">
Scope resolution (::)
</h4>
<div id="outline-text-headline-15" class="outline-text-4">
<p>To access a certain scope</p>
</div>
</div>
<div id="outline-container-headline-16" class="outline-4">
<h4 id="headline-16">
Math operators
</h4>
<div id="outline-text-headline-16" class="outline-text-4">
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  <span style="color:#888;font-weight:bold">int</span> n = <span style="color:#00d;font-weight:bold">3</span>;
  <span style="color:#080;font-weight:bold">if</span> (n &amp; <span style="color:#00d;font-weight:bold">1</span>)
    std::cout &lt;&lt; n % <span style="color:#00d;font-weight:bold">2</span>;
}</code></pre></div>
</div>
<pre class="example">
1
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-17" class="outline-3">
<h3 id="headline-17">
Bitwise left and right shift (&lt;&lt;, &gt;&gt;)
</h3>
<div id="outline-text-headline-17" class="outline-text-3">
<p>
These operators shift bits.</p>
<p>
All information is stored in the computer in a bit form.
For 32-bit storage system, there are 32 bits and each can be 0 or 1.
1 byte is equivalent to 8-bits.
Shifting a bit means shifting the 0 and 1 pattern to left or right.</p>
<p>
The right shift operator <code class="verbatim">&gt;&gt;</code></p>
</div>
</div>
<div id="outline-container-headline-18" class="outline-3">
<h3 id="headline-18">
Semicolon
</h3>
<div id="outline-text-headline-18" class="outline-text-3">
<ol>
<li>
<p>after class and structure definitions</p>
</li>
<li>
<p>after variable declaration</p>
</li>
<li>
<p>after function declaration</p>
</li>
<li>
<p>does not need</p>
<ol>
<li>
<p>after main function</p>
</li>
<li>
<p>after function definition in general</p>
</li>
<li>
<p>after the constructor of a class (which is a function)</p>
</li>
</ol>
</li>
</ol>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">func_declaration</span> (<span style="color:#888;font-weight:bold">int</span> x); <span style="color:#888">// DECLARE a function requires ;
</span><span style="color:#888"></span><span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">func_declaration</span>(<span style="color:#888;font-weight:bold">int</span> x) {    <span style="color:#888">// defines a function
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> y = x;
}				     <span style="color:#888">// DEFINE a function does not requires ;
</span><span style="color:#888"></span><span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() { func_declaration(<span style="color:#00d;font-weight:bold">10</span>); } <span style="color:#888">// does not require ;
</span></code></pre></div>
</div>
<div id="outline-container-headline-19" class="outline-3">
<h3 id="headline-19">
Move semantics
</h3>
<div id="outline-text-headline-19" class="outline-text-3">
<div id="outline-container-headline-20" class="outline-4">
<h4 id="headline-20">
What is the difference <code class="verbatim">rvalues</code> and <code class="verbatim">lvalues</code>?
</h4>
<div id="outline-text-headline-20" class="outline-text-4">
<p>
<code class="verbatim">rvalues</code> correspond to <strong>temporary</strong> <span style="text-decoration: underline;">objects returned from functions</span>.</p>
<p>
<code class="verbatim">lvalues</code> correspond to objects you can refer by <span style="text-decoration: underline;">name</span> or by <span style="text-decoration: underline;">following a pointer</span> or <span style="text-decoration: underline;"><code class="verbatim">rvalue</code> reference</span>.
For <code class="verbatim">lvalues</code> you can, generally, get its address, we say that <em>it can be addressed</em>.</p>
<p>
<code class="verbatim">rvalues</code> are eligible for move operations, <code class="verbatim">lvalues</code> are not.
Move constructors are useful to avoid copying the object when the initialization is done with a function return.
This improves performance.</p>
<p>
For instance, in <code class="verbatim">int var = foo(arg)</code>, <code class="verbatim">var</code> is <em>lvalue</em> because it has a name and can be addressed and <code class="verbatim">foo(arg)</code> is an <em>rvalue</em>. </p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">widget</span> (<span style="color:#888;font-weight:bold">int</span>&amp; v){}
<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">widget2</span> (<span style="color:#888;font-weight:bold">int</span>&amp;&amp; v){}

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> a = <span style="color:#00d;font-weight:bold">1</span>;
  widget(a);			<span style="color:#888">// allowed, a has an address
</span><span style="color:#888"></span>  <span style="color:#888">// widget(10);                // error 
</span><span style="color:#888"></span>  widget2(<span style="color:#00d;font-weight:bold">10</span>);			<span style="color:#888">// allowed, widget2 recieves rvalue reference &amp;&amp;
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<p>
Remarks:</p>
<ol>
<li>
<p>error: <code class="verbatim">cannot bind non-const lvalue reference of type ‘int&amp;’ to an rvalue of type ‘int’</code>.</p>
<ol>
<li>
<p>because the <code class="verbatim">10</code> is an rvalue with no address to be referenced.</p>
</li>
</ol>
</li>
<li>
<p>when <code class="verbatim">widget2() is called</code> it accepts the rvalue 10 because of the <code class="verbatim">&amp;&amp;</code> rvalue reference operator.</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-21" class="outline-4">
<h4 id="headline-21">
What is the difference between <em>move operator</em> and <em>copy operator</em>?
</h4>
<div id="outline-text-headline-21" class="outline-text-4">
<p>
When creating an <span style="text-decoration: underline;">new object</span> by calling the constructor, the <span style="text-decoration: underline;">source object</span> passed to the constructor can have its members fields <em>copied</em> or <em>moved</em> into the new object.</p>
<p>
A <em>copy constructor</em> does not change the source object.
Therefore it allocates its own copy of the object data in memory.
Then, there will be the same data in two locations in memory.</p>
<p>
A <em>move constructor</em> just &#34;move&#34; the data by using the pointer that refers to it.
The new object now refers to the original data in memory.
This makes this constructor <strong>more efficient</strong> because the data is located at only one place in memory.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;string&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;utility&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;vector&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>(std::vector&lt;<span style="color:#888;font-weight:bold">int</span>&gt; v) {
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;[&#34;</span>;
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#080;font-weight:bold">auto</span> <span style="color:#369;font-style:italic">elem</span>: v) {std::cout &lt;&lt; elem &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;}
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;]&#34;</span> &lt;&lt; std::endl;
}
 
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Widget</span> {
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">int</span> var;
  std::vector&lt;<span style="color:#888;font-weight:bold">int</span>&gt; vec;

  Widget(<span style="color:#888;font-weight:bold">int</span> a, std::vector&lt;<span style="color:#888;font-weight:bold">int</span>&gt; v) : var{a}, vec{v} {} <span style="color:#888">// constructor
</span><span style="color:#888"></span>
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print</span>(std::string label) {
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;obj: &#34;</span> &lt;&lt; label &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;</span><span style="color:#04d;background-color:#fff0f0">\n</span><span style="color:#d20;background-color:#fff0f0"> stored in: &#34;</span> &lt;&lt; &amp;var &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; with value: &#34;</span> &lt;&lt; var &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;</span><span style="color:#04d;background-color:#fff0f0">\n</span><span style="color:#d20;background-color:#fff0f0">&#34;</span>;
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; vector stored in: &#34;</span> &lt;&lt; vec.data() &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; value: &#34;</span>;
    print_vec(vec);
  }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> (){
  Widget obj1(<span style="color:#00d;font-weight:bold">10</span>, {<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">2</span>, <span style="color:#00d;font-weight:bold">3</span>, <span style="color:#00d;font-weight:bold">4</span>});
  obj1.print(<span style="color:#d20;background-color:#fff0f0">&#34;1 original&#34;</span>);

  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;</span><span style="color:#04d;background-color:#fff0f0">\n</span><span style="color:#d20;background-color:#fff0f0"> COPY&#34;</span> &lt;&lt; std::endl; 
  <span style="color:#080;font-weight:bold">auto</span> obj2 = obj1;		<span style="color:#888">// make a COPY!
</span><span style="color:#888"></span>  obj2.print(<span style="color:#d20;background-color:#fff0f0">&#34;2&#34;</span>);		<span style="color:#888">// SAME value, DIFFERENT memory location
</span><span style="color:#888"></span>  obj1.print(<span style="color:#d20;background-color:#fff0f0">&#34;1 after been copied&#34;</span>);

  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;</span><span style="color:#04d;background-color:#fff0f0">\n</span><span style="color:#d20;background-color:#fff0f0"> MOVE&#34;</span> &lt;&lt; std::endl; 
  obj1.print(<span style="color:#d20;background-color:#fff0f0">&#34;1 original&#34;</span>);
  <span style="color:#080;font-weight:bold">auto</span> obj3 = std::move(obj1);	<span style="color:#888">// MOVE constructor
</span><span style="color:#888"></span>  obj3.print(<span style="color:#d20;background-color:#fff0f0">&#34;3&#34;</span>);		<span style="color:#888">// only vecotr SAME MEMORY location
</span><span style="color:#888"></span>  obj1.print(<span style="color:#d20;background-color:#fff0f0">&#34;1 after beed moved&#34;</span>);
}</code></pre></div>
</div>
<pre class="example">
obj: 1 original
 stored in: 0x7ffc6ae19510 with value: 10
 vector stored in: 0x562d437bded0 value: [1, 2, 3, 4, ]

 COPY
obj: 2
 stored in: 0x7ffc6ae19530 with value: 10
 vector stored in: 0x562d437bdeb0 value: [1, 2, 3, 4, ]
obj: 1 after been copied
 stored in: 0x7ffc6ae19510 with value: 10
 vector stored in: 0x562d437bded0 value: [1, 2, 3, 4, ]

 MOVE
obj: 1 original
 stored in: 0x7ffc6ae19510 with value: 10
 vector stored in: 0x562d437bded0 value: [1, 2, 3, 4, ]
obj: 3
 stored in: 0x7ffc6ae19550 with value: 10
 vector stored in: 0x562d437bded0 value: [1, 2, 3, 4, ]
obj: 1 after beed moved
 stored in: 0x7ffc6ae19510 with value: 10
 vector stored in: 0 value: []
</pre>
<p>
Remarks:</p>
<ol>
<li>
<p>when copying, data is copied to another address</p>
<ol>
<li>
<p>the <span style="text-decoration: underline;">value is the same</span> but it is stored in a <span style="text-decoration: underline;">different memory address</span></p>
</li>
<li>
<p>nothing changes with the original object</p>
</li>
</ol>
</li>
<li>
<p>when moving, the data moves to another object</p>
<ol>
<li>
<p>the vector gets the <span style="text-decoration: underline;">same address and value</span> as the original one</p>
</li>
<li>
<p>the integer is copied because it is small and cheap, so it gets a new address</p>
</li>
<li>
<p>the original object has <span style="text-decoration: underline;">no more vector data</span> (<code class="verbatim">nullpointer</code> and value)</p>
</li>
</ol>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-22" class="outline-3">
<h3 id="headline-22">
Type safety
</h3>
<div id="outline-text-headline-22" class="outline-text-3">
<p>When each object has a type and are used according to the rules for their type.
Avoid uninitialized variables so the type is clear.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
<span style="color:#888;font-weight:bold">double</span> x;			<span style="color:#888">// declares WITHOU INITIALIZING!
</span><span style="color:#888"></span><span style="color:#888;font-weight:bold">double</span> y = x;			<span style="color:#888">// value of y still undefined
</span><span style="color:#888"></span><span style="color:#888;font-weight:bold">double</span> z = <span style="color:#00d;font-weight:bold">2.0</span> + x;		<span style="color:#888">// meaning of &#34;+&#34; and the value of z are undefined!
</span><span style="color:#888"></span>}</code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-23" class="outline-3">
<h3 id="headline-23">
<span class="todo">TODO</span>
Overloading
</h3>
</div>
<div id="outline-container-headline-24" class="outline-3">
<h3 id="headline-24">
<code class="verbatim">const</code> correctness
</h3>
<div id="outline-text-headline-24" class="outline-text-3">
<p>
Using <code class="verbatim">const</code> makes the code more readable.
When you see a <code class="verbatim">const</code> before a function you know it will not change the object.</p>
<p>
<code class="verbatim">const</code> arguments in functions make them more general.
We can pass a non constant variable to a function that expects a <code class="verbatim">const</code> argument, but we can not pass a <code class="verbatim">const</code> value to a function with non-constant arguments.</p>
</div>
</div>
<div id="outline-container-headline-25" class="outline-3">
<h3 id="headline-25">
Passing parameter by value
</h3>
<div id="outline-text-headline-25" class="outline-text-3">
<p>
Passing a parameter by value implies that the function will make a copy of it.
This allows we make any changes we want to the variable.
However it is error prone an hard to read.</p>
<p>
If you want pass an input variable only, make it <code class="verbatim">const.</code></p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">foo</span>(<span style="color:#888;font-weight:bold">int</span> arg) {
  arg = arg * <span style="color:#00d;font-weight:bold">2</span>;
  std::cout &lt;&lt; arg &lt;&lt; std::endl;
}
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> a{<span style="color:#00d;font-weight:bold">1</span>};
  foo(a);			<span style="color:#888">// modified a inside foo
</span><span style="color:#888"></span>  std::cout &lt;&lt; a;		<span style="color:#888">// original a unchanged
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
2
1
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-26" class="outline-2">
<h2 id="headline-26">
Basics
</h2>
<div id="outline-text-headline-26" class="outline-text-2">
<div id="outline-container-headline-27" class="outline-3">
<h3 id="headline-27">
Minimal program
</h3>
<div id="outline-text-headline-27" class="outline-text-3">
<p>Defines a function with no arguments, empty (), and does nothing, empty {}.</p>
<p>
Every program needs a <code class="verbatim">main</code> function.
The <code class="verbatim">int</code> is the value returned by the function.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {}</code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-28" class="outline-3">
<h3 id="headline-28">
Hello world
</h3>
<div id="outline-text-headline-28" class="outline-text-3">
<p>
Include the declarations of the standard stream I/O facilities.
Operator <code class="verbatim">&lt;&lt;</code> writes the second argument (string) to the first (standard output stream <code class="verbatim">std:cout</code>).
The <code class="verbatim">std::</code> indicates that it is in the standard library namespace.
If does not want to write every time, add <code class="verbatim">using namespace std;</code> in the beginning of file.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;Hello&#34;</span>;
}</code></pre></div>
</div>
<pre class="example">
Hello
</pre>
</div>
</div>
<div id="outline-container-headline-29" class="outline-3">
<h3 id="headline-29">
Functions
</h3>
<div id="outline-text-headline-29" class="outline-text-3">
<p>
A function is declared with its name, type of the returned value, number and types of arguments.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">square</span> (<span style="color:#888;font-weight:bold">double</span> value) {
  <span style="color:#080;font-weight:bold">return</span> value * value;
}

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  cout &lt;&lt; square(<span style="color:#00d;font-weight:bold">10</span>);
}</code></pre></div>
</div>
<pre class="example">
100
</pre>
</div>
</div>
<div id="outline-container-headline-30" class="outline-3">
<h3 id="headline-30">
Scope
</h3>
<div id="outline-text-headline-30" class="outline-text-3">
<p>Scopes can be started with curly braces <code class="verbatim">{}.</code>
Any objects that are declared within the scope are allocated in memory only during the execution of that scope.</p>
<p>
Local scope: declarations in a function.</p>
<p>
Namespace scope: a name is <em>namespace member name</em> if it is declared outside any function.
Its scope extends from the point of declaration to the end of its namespace.</p>
<p>
There are objects without a name, temporary objects created with <code class="verbatim">new</code></p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;vector&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

vector&lt;<span style="color:#888;font-weight:bold">int</span>&gt; vec; 		<span style="color:#888">// GLOBAL vector of integers
</span><span style="color:#888"></span>
<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">fct</span> (<span style="color:#888;font-weight:bold">int</span> arg) {
  string motto {<span style="color:#d20;background-color:#fff0f0">&#34;Something&#34;</span>}; 	<span style="color:#888">// LOCAL variable
</span><span style="color:#888"></span>}

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  vec.push_back(<span style="color:#00d;font-weight:bold">10</span>);		<span style="color:#888">// add 10 to the vector
</span><span style="color:#888"></span>  cout &lt;&lt; vec[<span style="color:#00d;font-weight:bold">0</span>];		<span style="color:#888">// vec first entry
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
10
</pre>
</div>
</div>
<div id="outline-container-headline-31" class="outline-3">
<h3 id="headline-31">
Pointers
</h3>
<div id="outline-text-headline-31" class="outline-text-3">
<p>
The operator <code class="verbatim">*</code> means &#34;pointer to&#34;, also understood as &#34;contents of&#34;
A pointer variable <span style="text-decoration: underline;">holds the address</span> of an object.
The address can be used to access a value.</p>
<p>
The symbol <code class="verbatim">&amp;</code> means &#34;address of&#34;.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  <span style="color:#888;font-weight:bold">int</span> v[<span style="color:#00d;font-weight:bold">6</span>] = {<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">9</span>, <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>};			<span style="color:#888">// array of 6 int from 0 to 5
</span><span style="color:#888"></span>  cout &lt;&lt; v[<span style="color:#00d;font-weight:bold">3</span>] &lt;&lt; endl;
  <span style="color:#888;font-weight:bold">int</span>* p = &amp;v[<span style="color:#00d;font-weight:bold">3</span>];			<span style="color:#888">// p points to v 4th element ADDRESS
</span><span style="color:#888"></span>  cout &lt;&lt; p &lt;&lt; endl;			<span style="color:#888">// prints the memmory address
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> x = *p;			<span style="color:#888">// *p is the object that p points to... meaning the 4th array element
</span><span style="color:#888"></span>  cout &lt;&lt; x &lt;&lt; endl;
  <span style="color:#888;font-weight:bold">int</span>* y = p;			<span style="color:#888">// pass the ADDRESS to another pointer
</span><span style="color:#888"></span>  cout &lt;&lt; y;
}</code></pre></div>
</div>
<pre class="example">
9
0x7ffc231cc0ac
9
0x7ffc231cc0ac
</pre>
</div>
</div>
<div id="outline-container-headline-32" class="outline-3">
<h3 id="headline-32">
<code class="verbatim">new</code> operator
</h3>
<div id="outline-text-headline-32" class="outline-text-3">
<p>
<span style="text-decoration: underline;">Returns a pointer</span> to the object it creates.
If it creates multiple objects it returns a pointer to the first.</p>
<p>
About memory.</p>
<ol>
<li>
<p>the <code class="verbatim">new</code> operator allows the program to use the <span style="text-decoration: underline;">free store memory</span>, or <em>heap</em></p>
</li>
<li>
<p>if you don&#39;t delete the pointer it causes <span style="text-decoration: underline;">memory leak</span></p>
</li>
<li>
<p>as alternative to use the operator, the object creation could use stack memory (local variables)</p>
<ol>
<li>
<p>if too many object are allocated it risks <span style="text-decoration: underline;">stack overflow</span></p>
</li>
</ol>
</li>
</ol>
<p>Notes:</p>
<ol>
<li>
<p><code class="verbatim">[]</code> indicates array</p>
</li>
<li>
<p><code class="verbatim">{}</code> initialize variable preferred way instead of <code class="verbatim">()</code></p>
</li>
</ol>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">double</span> *p = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[<span style="color:#00d;font-weight:bold">4</span>]; <span style="color:#888">// creates a variable p which is a pointer
</span><span style="color:#888"></span>  std::cout &lt;&lt; p &lt;&lt; std::endl;	     <span style="color:#888">// new returns the pointer to the first of the array of double
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> *pi = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">int</span>;		     <span style="color:#888">// new integer pointer to pi
</span><span style="color:#888"></span>  std::cout &lt;&lt; pi &lt;&lt; std::endl;
  <span style="color:#888;font-weight:bold">double</span> *p2 = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>{<span style="color:#00d;font-weight:bold">5.5</span>}; <span style="color:#888">// initialize with {}, p2 points to memory
</span><span style="color:#888"></span>                                <span style="color:#888">// address that has 5.5 as value
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;Address: &#34;</span> &lt;&lt; p2 &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; value: &#34;</span> &lt;&lt; *p2;
}</code></pre></div>
</div>
<pre class="example">
0x55be16a1beb0
0x55be16a1cef0
Address: 0x55be16a1cf10 value: 5.5
</pre>
</div>
</div>
<div id="outline-container-headline-33" class="outline-3">
<h3 id="headline-33">
<code class="verbatim">const</code> operator
</h3>
<div id="outline-text-headline-33" class="outline-text-3">
<div id="outline-container-headline-34" class="outline-4">
<h4 id="headline-34">
<code class="verbatim">const</code> variable
</h4>
<div id="outline-text-headline-34" class="outline-text-4">
<p>As the name suggests, it makes the variable unchangeable.</p>
<p>
On the other hand, <code class="verbatim">constexpr</code> are evaluated at compile time.
Allows placement of data for read only, improving performance.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#080;font-weight:bold">const</span> <span style="color:#888;font-weight:bold">int</span> dmv = <span style="color:#00d;font-weight:bold">17</span>;
<span style="color:#080;font-weight:bold">constexpr</span> <span style="color:#888;font-weight:bold">double</span> max1 = <span style="color:#00d;font-weight:bold">1.2</span> * dmv;

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
    cout &lt;&lt; max1;
}</code></pre></div>
</div>
<pre class="example">
20.4
</pre>
</div>
</div>
<div id="outline-container-headline-35" class="outline-4">
<h4 id="headline-35">
<code class="verbatim">const</code> pointer
</h4>
<div id="outline-text-headline-35" class="outline-text-4">
<p>
If <code class="verbatim">const</code> is AFTER <code class="verbatim">*</code> we can not change the <span style="text-decoration: underline;">pointer content</span>, but pointer itself we can.
We can understand as the operator qualifying the symbol of the pointer.</p>
<p>
If <code class="verbatim">const</code> is BEFORE <code class="verbatim">*</code> we can change the pointer itself, but not the content.
Understand as <code class="verbatim">const</code> operator qualifying the <code class="verbatim">*</code> which indicates the pointer target.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> *<span style="color:#080;font-weight:bold">const</span> pt = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">int</span>; <span style="color:#888">// const after -&gt; pointer itself constant
</span><span style="color:#888"></span>  *pt = <span style="color:#00d;font-weight:bold">12030</span>;             <span style="color:#888">// change pointer content, ALLOWED!
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;pointer: &#34;</span> &lt;&lt; pt &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; points to: &#34;</span> &lt;&lt; *pt &lt;&lt; std::endl;
  <span style="color:#888">// pt = new int;			// error: assignment of read-only
</span><span style="color:#888"></span>  <span style="color:#888">// variable ‘pt’
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> <span style="color:#080;font-weight:bold">const</span> *pt2 = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">int</span>; <span style="color:#888">// conts before -&gt; content constant
</span><span style="color:#888"></span>  pt2 = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">int</span>;            <span style="color:#888">// change pointer itself ALLOWED!
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;pointer: &#34;</span> &lt;&lt; pt2 &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; points to: &#34;</span> &lt;&lt; *pt2 &lt;&lt; std::endl;
  <span style="color:#888">// *pt2 = 12039;			// error: assignment of read-only
</span><span style="color:#888"></span>  <span style="color:#888">// location ‘* pt2’
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
pointer: 0x5604e06d3eb0 points to: 12030
pointer: 0x5604e06d4f00 points to: 0
</pre>
</div>
</div>
<div id="outline-container-headline-36" class="outline-4">
<h4 id="headline-36">
<code class="verbatim">const</code> function argument
</h4>
<div id="outline-text-headline-36" class="outline-text-4">
<p>
Function argument is only readable.</p>
</div>
</div>
<div id="outline-container-headline-37" class="outline-4">
<h4 id="headline-37">
<code class="verbatim">const</code> after the arguments of a member function
</h4>
<div id="outline-text-headline-37" class="outline-text-4">
<p>
In a class definition.
The whole member function can be <code class="verbatim">const</code>, meaning that the function can not change object member variable.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">MyClass</span> {
  <span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">int</span> var;
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">func1</span> () {var = <span style="color:#00d;font-weight:bold">1</span>;}	<span style="color:#888">// change member variable ALLOWED!
</span><span style="color:#888"></span>  <span style="color:#888">// void func2 () const {var = 1;} // error: assignment of member varialbe in READ-ONLY object
</span><span style="color:#888"></span>};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  MyClass obj; 
}</code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-38" class="outline-3">
<h3 id="headline-38">
Declarator operators
</h3>
<div id="outline-text-headline-38" class="outline-text-3">
<ol>
<li>
<p><code class="verbatim">T a[n];</code> array named &#34;a&#34; of n Ts (type)</p>
</li>
<li>
<p><code class="verbatim">T* p;</code> pointer to T</p>
</li>
<li>
<p><code class="verbatim">T&amp; r;</code> reference to T</p>
</li>
<li>
<p><code class="verbatim">T f(A);</code> function taking argument of type A and returning a result of type T</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-39" class="outline-3">
<h3 id="headline-39">
Range-for-statement
</h3>
<div id="outline-text-headline-39" class="outline-text-3">
<p>
For loops that go over a sequence.
Does not need a counting variable.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print</span> () {
  <span style="color:#888;font-weight:bold">int</span> v[] = {<span style="color:#00d;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">3</span>};		<span style="color:#888">// create array
</span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#080;font-weight:bold">auto</span> <span style="color:#369;font-style:italic">x</span> : v)
    cout &lt;&lt; x &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;</span><span style="color:#04d;background-color:#fff0f0">\n</span><span style="color:#d20;background-color:#fff0f0">&#34;</span>;
}
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  print();			<span style="color:#888">// call function
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
0
1
3
</pre>
</div>
</div>
<div id="outline-container-headline-40" class="outline-3">
<h3 id="headline-40">
Tests
</h3>
<div id="outline-text-headline-40" class="outline-text-3">
<p>
If statements.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> (){
  <span style="color:#888;font-weight:bold">int</span> answer = <span style="color:#00d;font-weight:bold">2</span>;
  <span style="color:#080;font-weight:bold">if</span> (answer == <span style="color:#00d;font-weight:bold">2</span>)
    cout &lt;&lt; answer;
}</code></pre></div>
</div>
<pre class="example">
2
</pre>
</div>
</div>
<div id="outline-container-headline-41" class="outline-3">
<h3 id="headline-41">
Variable initialization
</h3>
<div id="outline-text-headline-41" class="outline-text-3">
<p>
Use <code class="verbatim">{}</code> to initialize.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">fun</span>(<span style="color:#888;font-weight:bold">double</span> float_arg) {
  <span style="color:#888;font-weight:bold">int</span> a = float_arg; <span style="color:#888">// converts float into int () (BAD!)
</span><span style="color:#888"></span>  std::cout &lt;&lt; a &lt;&lt; std::endl;
  <span style="color:#888;font-weight:bold">int</span> b{float_arg};		<span style="color:#888">// error: possile truncation (GOOD!) compiler works but...
</span><span style="color:#888"></span>  std::cout &lt;&lt; b &lt;&lt; std::endl;
  <span style="color:#888;font-weight:bold">double</span> c{float_arg}; <span style="color:#888">// better to correcly specify the type
</span><span style="color:#888"></span>  std::cout &lt;&lt; c &lt;&lt; std::endl;
  <span style="color:#080;font-weight:bold">return</span> a;
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () { fun(<span style="color:#00d;font-weight:bold">1.3209</span>);}</code></pre></div>
</div>
<pre class="example">
1
1
1.3209
</pre>
</div>
</div>
<div id="outline-container-headline-42" class="outline-3">
<h3 id="headline-42">
<code class="verbatim">cout</code> versus <code class="verbatim">printf</code>
</h3>
<div id="outline-text-headline-42" class="outline-text-3">
<ol>
<li>
<p><code class="verbatim">cout</code> is C++ and <code class="verbatim">printf</code> is C but it can be used in C++.</p>
</li>
<li>
<p><code class="verbatim">cout</code> is extensible.</p>
</li>
<li>
<p><code class="verbatim">printf</code> uses standard function syntax.</p>
</li>
<li>
<p>C++ FAQ suggests using &lt;iostream&gt; <code class="verbatim">cout</code> instead of &lt;cstdio&gt; <code class="verbatim">printf</code>;</p>
<ol>
<li>
<p>increase type safety, reduce errors, allow extensibility, provide inheritability.</p>
</li>
</ol>
</li>
</ol>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#888;font-weight:bold">int</span> a=<span style="color:#00d;font-weight:bold">1</span>;
<span style="color:#888;font-weight:bold">int</span> b=<span style="color:#00d;font-weight:bold">1</span>;
std::cout &lt;&lt; a+b &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;</span><span style="color:#04d;background-color:#fff0f0">\n</span><span style="color:#d20;background-color:#fff0f0">&#34;</span>;
printf(<span style="color:#d20;background-color:#fff0f0">&#34;%d</span><span style="color:#04d;background-color:#fff0f0">\n</span><span style="color:#d20;background-color:#fff0f0">&#34;</span>, a+b);</code></pre></div>
</div>
<pre class="example">
2
2
</pre>
</div>
</div>
<div id="outline-container-headline-43" class="outline-3">
<h3 id="headline-43">
How many bytes?
</h3>
<div id="outline-text-headline-43" class="outline-text-3">
<p>
Number of <span style="text-decoration: underline;">bytes</span> to store an information type.
This number of bytes is required to storage the specific object in memory.
The computer memory can be viewed as a sequence of <span style="text-decoration: underline;">bytes</span> 0 and 1.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std::cout &lt;&lt; <span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#888;font-weight:bold">int</span>) &lt;&lt; std::endl;
std::cout &lt;&lt; <span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#888;font-weight:bold">double</span>) &lt;&lt; std::endl;
std::cout &lt;&lt; <span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#888;font-weight:bold">bool</span>) &lt;&lt; std::endl;</code></pre></div>
</div>
<pre class="example">
4
8
1
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-44" class="outline-2">
<h2 id="headline-44">
Pointers
</h2>
<div id="outline-text-headline-44" class="outline-text-2">
<div id="outline-container-headline-45" class="outline-3">
<h3 id="headline-45">
Memory
</h3>
<div id="outline-text-headline-45" class="outline-text-3">
<p>
Computer memory is a sequence of bytes.
The location in memory is the specific byte position in the sequence, called <span style="text-decoration: underline;">address</span> of the byte.
Everything in memory has an address.</p>
<p>
The type of variable will define the memory size required to store that variable type.
The amount of memory can be viewed with <code class="verbatim">sizeof</code> operator.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  <span style="color:#888;font-weight:bold">int</span> x = <span style="color:#00d;font-weight:bold">17</span>; <span style="color:#888">// define integer
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> *pi = &amp;x; <span style="color:#888">// definer a /pointer to int/ with the address of x
</span><span style="color:#888"></span>  std::cout &lt;&lt; pi &lt;&lt; std::endl;
  std::cout &lt;&lt; <span style="color:#080;font-weight:bold">sizeof</span>(pi);	<span style="color:#888">// size of a pointer to integer
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
0x7ffdde0a297c
8
</pre>
</div>
</div>
<div id="outline-container-headline-46" class="outline-3">
<h3 id="headline-46">
Pointer definition
</h3>
<div id="outline-text-headline-46" class="outline-text-3">
<p>
<span style="text-decoration: underline;">A pointer is an object that holds a memory address value.</span>
A pointer can &#34;point&#34; to anything that can be placed in memory.
We can refer to it as &#34;values in&#34; the pointer.</p>
</div>
</div>
<div id="outline-container-headline-47" class="outline-3">
<h3 id="headline-47">
Pointer type
</h3>
<div id="outline-text-headline-47" class="outline-text-3">
<p>The type needed to hold an address of a type is specified with <code class="verbatim">&lt;type&gt;*</code>.
For instance, the type that holds a pointer to an <code class="verbatim">int</code> is <code class="verbatim">int*</code>, which can be referred to as &#34;pointer to int type&#34;, or &#34;int pointer type&#34;.</p>
<p>
To create a pointer type object we can use <code class="verbatim">&amp;</code> to get an address or <code class="verbatim">new</code> to generate one.</p>
</div>
</div>
<div id="outline-container-headline-48" class="outline-3">
<h3 id="headline-48">
&#34;Address of&#34; operator (&amp;)
</h3>
<div id="outline-text-headline-48" class="outline-text-3">
<p><span style="text-decoration: underline;">A pointer is a variable that stores the address of another variable.</span></p>
<p>
Variables are locations in computer memory which are accessed by an identifier (name).</p>
<p>
Memory is a succession of cells with one byte in size with an unique address.</p>
<p>
It may be useful to get the memory address of a variable during runtime.
With this address we can access other data cells with a specific relative position.</p>
<p>
The address of a variable is obtained with the operator <code class="verbatim">&amp;</code>.
Other alternative to get a pointer is to use the operator <code class="verbatim">new</code> when creating an object.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> ()
{
  <span style="color:#888;font-weight:bold">int</span> var = <span style="color:#00d;font-weight:bold">10</span>;
  <span style="color:#888;font-weight:bold">int</span> *address_of_var = &amp;var;	<span style="color:#888">// * indicates that this variable is a pointer
</span><span style="color:#888"></span>  cout &lt;&lt; address_of_var;	<span style="color:#888">// memmory address of variable var
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
0x7ffc1a43fc2c
</pre>
</div>
</div>
<div id="outline-container-headline-49" class="outline-3">
<h3 id="headline-49">
&#34;Contents of&#34; operator (*)
</h3>
<div id="outline-text-headline-49" class="outline-text-3">
<p>
Pointers have the addresses.
This address may be populated with a variable value.
So, pointers can be used to <span style="text-decoration: underline;">access the variable they point to</span>.</p>
<p>
The operator <code class="verbatim">*</code> means &#34;value pointed to by&#34;.
Also called <em>dereference</em> operator and <em>indirection</em> operator.
We can use it to change the <span style="text-decoration: underline;">content of an object through a pointer</span>.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  <span style="color:#888;font-weight:bold">int</span> var = <span style="color:#00d;font-weight:bold">2</span>;
  <span style="color:#888;font-weight:bold">int</span>* var_pointer = &amp;var;		<span style="color:#888">// stores the address to var
</span><span style="color:#888"></span>  std::cout &lt;&lt; var_pointer &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;</span><span style="color:#04d;background-color:#fff0f0">\n</span><span style="color:#d20;background-color:#fff0f0">&#34;</span>;		<span style="color:#888">// pointer refers to ADDRESS
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> c = *var_pointer;			<span style="color:#888">// * get the VALUE THAT THE ADDRESS is pointing to (2)
</span><span style="color:#888"></span>  std::cout &lt;&lt; c;
}</code></pre></div>
</div>
<pre class="example">
0x7ffdcb5ee548
2
</pre>
</div>
</div>
<div id="outline-container-headline-50" class="outline-3">
<h3 id="headline-50">
Access object pointed to by a pointer
</h3>
<div id="outline-text-headline-50" class="outline-text-3">
<p>
We can use the operator <code class="verbatim">*</code> or <code class="verbatim">[]</code> to access an object <em>pointed to by a pointer</em>.
We can then use the pointer to change the <span style="text-decoration: underline;">content</span>.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>(){
  <span style="color:#888;font-weight:bold">int</span> x = <span style="color:#00d;font-weight:bold">10</span>;
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;original object: &#34;</span> &lt;&lt; x &lt;&lt; std::endl;
  <span style="color:#888;font-weight:bold">int</span>*p = &amp;x;			<span style="color:#888">// p points to address of x
</span><span style="color:#888"></span>  *p = <span style="color:#00d;font-weight:bold">7</span>;			<span style="color:#888">// change object content through a pointer
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;changed object: &#34;</span> &lt;&lt; x &lt;&lt; std::endl;
  
}</code></pre></div>
</div>
<pre class="example">
original object: 10
changed object: 7
</pre>
</div>
</div>
<div id="outline-container-headline-51" class="outline-3">
<h3 id="headline-51">
Null pointer
</h3>
<div id="outline-text-headline-51" class="outline-text-3">
<p>
When you don&#39;t have any pointer to use to initialize a pointer you can use <code class="verbatim">double* ptr = nullptr;</code></p>
<p>
<code class="verbatim">if(ptr)</code> checks if the pointer is valid, non <code class="verbatim">nullptr</code>.
Using <code class="verbatim">0</code> and <code class="verbatim">NULL</code> is deprecated in favor of the new <code class="verbatim">nullptr</code> which is mode specific and clear.</p>
</div>
</div>
<div id="outline-container-headline-52" class="outline-3">
<h3 id="headline-52">
References
</h3>
<div id="outline-text-headline-52" class="outline-text-3">
<p>
A reference is a immutable pointer.</p>
<p>
When the operator <code class="verbatim">&amp;</code> is in the type instead of in the initializer we <span style="text-decoration: underline;">create a reference</span>.</p>
<p>
When we want to change the original referenced content we don&#39;t need the <code class="verbatim">*</code> like in with the pointer.
Therefore, a reference acts just like the variable itself, like an <strong>alias</strong>.</p>
<ol>
<li>
<p>change the referenced content without <code class="verbatim">*</code></p>
</li>
<li>
<p>read referenced content without <code class="verbatim">*</code></p>
</li>
<li>
<p>CAN NOT change the reference address</p>
<ol>
<li>
<p>there is no way to get a reference to refer to a different object after initilization</p>
</li>
<li>
<p>if there is a need to point to something different, a pointer should be used</p>
</li>
</ol>
</li>
</ol>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> var1 = <span style="color:#00d;font-weight:bold">10</span>;
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;va1: &#34;</span> &lt;&lt; var1 &lt;&lt; std::endl;
  <span style="color:#888;font-weight:bold">int</span>&amp; ref1 = var1;		<span style="color:#888">// create reference to var1
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;ref1: &#34;</span> &lt;&lt; ref1 &lt;&lt; std::endl;
  ref1 = <span style="color:#00d;font-weight:bold">7</span>; <span style="color:#888">// change the content through the reference WITHOUT *
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;ref1: &#34;</span> &lt;&lt; ref1 &lt;&lt; std::endl;
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;var1 changed through ref1: &#34;</span> &lt;&lt; var1 &lt;&lt; std::endl;
  
  <span style="color:#888;font-weight:bold">int</span> var2 = ref1;			<span style="color:#888">// read var1 through ref1 WITHOUT *
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;var2: &#34;</span> &lt;&lt; var2 &lt;&lt; std::endl;
  <span style="color:#888;font-weight:bold">int</span>&amp; ref2 = var2;		<span style="color:#888">// create reference to var2
</span><span style="color:#888"></span>  var1 = <span style="color:#00d;font-weight:bold">1</span>;
  ref2 = ref1;			<span style="color:#888">// CHANGE THE VALUE of VAR2 using ONLY references
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;var2: &#34;</span> &lt;&lt; var2 &lt;&lt; std::endl;
  <span style="color:#888">// ref1 = &amp;var2;			// error: invalid conversion from ‘int*’ to ‘int’
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
va1: 10
ref1: 10
ref1: 7
var1 changed through ref1: 7
var2: 7
var2: 1
</pre>
</div>
</div>
<div id="outline-container-headline-53" class="outline-3">
<h3 id="headline-53">
When to use references
</h3>
<div id="outline-text-headline-53" class="outline-text-3">
<p>
References are just like an <strong>alias</strong> for an object.
The reference has no information about the lifetime of the object, which can be automatic within a scope or manually allocated in the heap (free memory).</p>
<p>
The usage of references are preferred to pointers.</p>
<p>
An example is when we need to pass function arguments.
We can (i) pass by value, (ii) pass by reference.</p>
<p>
If we pass large objects as values it can impact the performance.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span> {
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">int</span> var = <span style="color:#00d;font-weight:bold">10</span>;
};
<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">f</span>(A&amp; ref) { <span style="color:#888">// f receives A instance ITSELF, CAN BE MODIFIED
</span><span style="color:#888"></span>  ref.var = <span style="color:#00d;font-weight:bold">2</span>;   <span style="color:#888">// change instance
</span><span style="color:#888"></span>}

<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">f2</span>(A ref) { <span style="color:#888">// f receives COPY of passed instance of A
</span><span style="color:#888"></span>  ref.var = <span style="color:#00d;font-weight:bold">20</span>;
}
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  A a;				<span style="color:#888">// create instance of A
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;original var: &#34;</span> &lt;&lt; a.var &lt;&lt; std::endl;
  f(a);				<span style="color:#888">// call function with REF
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;passed as reference: &#34;</span> &lt;&lt; a.var &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; CHANGED the instance!&#34;</span> &lt;&lt; std::endl;
  f2(a);
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;passed as value: &#34;</span> &lt;&lt; a.var &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; DOES NOT CHANGE the instance!&#34;</span>;
}</code></pre></div>
</div>
<pre class="example">
original var: 10
passed as reference: 2 CHANGED the instance!
passed as value: 2 DOES NOT CHANGE the instance!
</pre>
</div>
</div>
<div id="outline-container-headline-54" class="outline-3">
<h3 id="headline-54">
Pointer and reference parameters
</h3>
<div id="outline-text-headline-54" class="outline-text-3">
<p>
With the goal of changing the value of a variable to a value computed by a function we have 3 choices:</p>
<ol>
<li>
<p>pass the value to the function and return it</p>
</li>
<li>
<p>pass a pointer</p>
</li>
<li>
<p>pass a reference</p>
</li>
</ol>
<p>Passing a value is clear and simple when the <strong>object is small</strong>.
For large objects, pointers and references offer a more efficient alternative.</p>
<p>
The main difference between a pointer or reference in this case is when the pointer is passed, it is required to use the operator &#34;address of&#34;, <code class="verbatim">&amp;</code>, to get the pointer.
This is a visual cue that represents a <span style="text-decoration: underline;">situation where the variable value may change</span>.
Whereas passing a reference is not much different than passing the variable itself.</p>
<p>
Rule-of-thumb:</p>
<ol>
<li>
<p>small objects: pass-by-value.</p>
</li>
<li>
<p>function that accept &#34;no object&#34; use pointer parameter and manually handle the null pointer case.</p>
</li>
<li>
<p>otherwise: use reference parameter.</p>
</li>
</ol>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">incr_v</span>(<span style="color:#888;font-weight:bold">int</span> x) {<span style="color:#080;font-weight:bold">return</span> x + <span style="color:#00d;font-weight:bold">1</span>;}
<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">incr_p</span>(<span style="color:#888;font-weight:bold">int</span>* p) {++*p;}	<span style="color:#888">// passing the pointer and changing pointer content itself
</span><span style="color:#888"></span><span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">incr_r</span>(<span style="color:#888;font-weight:bold">int</span>&amp; r) {++r;}	<span style="color:#888">// passing a reference and changing the content itself
</span><span style="color:#888"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> x = <span style="color:#00d;font-weight:bold">2</span>;
  x = incr_v(x);			<span style="color:#888">// passing the VALUE and REASSINGN to the variable
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;value reassingned: &#34;</span> &lt;&lt; x &lt;&lt; std::endl;

  incr_p(&amp;x);			<span style="color:#888">// passing the pointer using &amp; to get the address of x
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;value changed by the function using pointer: &#34;</span> &lt;&lt; x &lt;&lt; std::endl;

  incr_r(x);
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;value changed by the function using reference: &#34;</span> &lt;&lt; x &lt;&lt; std::endl;
}</code></pre></div>
</div>
<pre class="example">
value reassingned: 3
value changed by the function using pointer: 4
value changed by the function using reference: 5
</pre>
</div>
</div>
<div id="outline-container-headline-55" class="outline-3">
<h3 id="headline-55">
Protecting data &#34;pointed to&#34; when passing by reference
</h3>
<div id="outline-text-headline-55" class="outline-text-3">
<p>
Problem:
When passing by reference, even with <code class="verbatim">const</code>, we can change the data &#34;pointed to&#34;.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;vector&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">foo</span>(<span style="color:#888;font-weight:bold">int</span> &amp;a, std::vector&lt;<span style="color:#888;font-weight:bold">int</span>&gt; &amp;vec) {
  a = a * <span style="color:#00d;font-weight:bold">2</span>; <span style="color:#888">// Can not modify const int reference
</span><span style="color:#888"></span>  vec[<span style="color:#00d;font-weight:bold">1</span>] = <span style="color:#00d;font-weight:bold">1999</span>;		<span style="color:#888">// modify vector through REFERENCE!
</span><span style="color:#888"></span>}
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> a{<span style="color:#00d;font-weight:bold">19</span>};
  std::cout &lt;&lt; a &lt;&lt; std::endl;
  std::vector&lt;<span style="color:#888;font-weight:bold">int</span>&gt; vec {<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">2</span>};
  std::cout &lt;&lt; vec[<span style="color:#00d;font-weight:bold">1</span>] &lt;&lt; std::endl;
  foo(a, vec);
  std::cout &lt;&lt; vec[<span style="color:#00d;font-weight:bold">1</span>] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; vec element modified!&#34;</span>&lt;&lt; std::endl;
  std::cout &lt;&lt; a &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; a modified! &#34;</span>&lt;&lt; std::endl;
  
}</code></pre></div>
</div>
<pre class="example">
19
2
1999 vec element modified!
38 a modified! 
</pre>
<p>
Remarks:</p>
<ol>
<li>
<p>when the function receives <code class="verbatim">const</code> argument it CAN NOT modify them.</p>
<ol>
<li>
<p>even with <code class="verbatim">[]</code></p>
</li>
<li>
<p>even if is a references to a vector.</p>
</li>
</ol>
</li>
<li>
<p>variable <code class="verbatim">a</code> passed by reference to function with <code class="verbatim">&amp;</code> is subject to modification!</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-56" class="outline-2">
<h2 id="headline-56">
Classes
</h2>
<div id="outline-text-headline-56" class="outline-text-2">
<div id="outline-container-headline-57" class="outline-3">
<h3 id="headline-57">
Definitionss
</h3>
<div id="outline-text-headline-57" class="outline-text-3">
<div id="outline-container-headline-58" class="outline-4">
<h4 id="headline-58">
Class and objects
</h4>
<div id="outline-text-headline-58" class="outline-text-4">
<p>
A class type specify <span style="text-decoration: underline;">how the object of its type are represented, how are they used and how they can be destroyed.</span></p>
<p>
A class creates an <span style="text-decoration: underline;">object blueprint</span>.</p>
<p>
An object is an <span style="text-decoration: underline;">instance of the class</span>.
When the class is called you create an instance of the object.</p>
</div>
</div>
<div id="outline-container-headline-59" class="outline-4">
<h4 id="headline-59">
Types
</h4>
<div id="outline-text-headline-59" class="outline-text-4">
<p>Types are a way to representing ideas in code.
A type knows how to represent the data in an object and which operations can be applied to it.</p>
</div>
</div>
<div id="outline-container-headline-60" class="outline-4">
<h4 id="headline-60">
User defined type (UDT)
</h4>
<div id="outline-text-headline-60" class="outline-text-4">
<p><strong>User defined types</strong> (UDT) can be used to implement high level facilities.
These types are built out of the built-in types and C++ abstraction mechanisms.
User defined types that C++ provides are: classes and enumerations.</p>
</div>
</div>
<div id="outline-container-headline-61" class="outline-4">
<h4 id="headline-61">
Built in types (BIT)
</h4>
<div id="outline-text-headline-61" class="outline-text-4">
<p><strong>Built in</strong> types (BIT) are recognized by the compiler without any declaration supplied by the programmer.</p>
</div>
</div>
<div id="outline-container-headline-62" class="outline-4">
<h4 id="headline-62">
Standard librar types (SLT)
</h4>
<div id="outline-text-headline-62" class="outline-text-4">
<p><strong>Standard library types</strong> (SLT) such as string, vector, ostream are considered user-defined types (UDT).
These types are part of C++ ISO standard implementation.
These are considered UDT because they are constructed from the same primitive as the UDT.</p>
</div>
</div>
<div id="outline-container-headline-63" class="outline-4">
<h4 id="headline-63">
Defining and instantiating an object
</h4>
<div id="outline-text-headline-63" class="outline-text-4">
<p>
When the blueprint of an object is created we are defining it.
When we call the blueprint we instantiate an object.</p>
</div>
</div>
<div id="outline-container-headline-64" class="outline-4">
<h4 id="headline-64">
Uses of classes
</h4>
<div id="outline-text-headline-64" class="outline-text-4">
<ol>
<li>
<p>grouping functions</p>
<ol>
<li>
<p>one class with multiple close related functions</p>
</li>
<li>
<p>eg: structure with error functions</p>
</li>
</ol>
</li>
<li>
<p>standardizing interface</p>
<ol>
<li>
<p>standard interface for different functionalities</p>
</li>
<li>
<p>eg: interface to probability distribution in a class, there are many different distributions each has its own class with a common structure/interface</p>
</li>
</ol>
</li>
<li>
<p>grouping multiple returns</p>
</li>
<li>
<p>save internal state for multiple uses</p>
<ol>
<li>
<p>a class that defines a type for a specific solution method</p>
</li>
<li>
<p>eg: a class for solving a linear system with LU decomposition. the class will store the system matrix and provide methods for solving, investing and computing the determinant</p>
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-65" class="outline-4">
<h4 id="headline-65">
Containers
</h4>
<div id="outline-text-headline-65" class="outline-text-4">
<p>A class that holds objects.</p>
<p>
The standard library provides the container vector for instance.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-66" class="outline-3">
<h3 id="headline-66">
Classes and members
</h3>
<div id="outline-text-headline-66" class="outline-text-3">
<p>
Members are parts used to define a class.
The member-access notation uses the <code class="verbatim">.</code>.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Myclass</span> {
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">int</span> m;		<span style="color:#888">// data member
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">method</span>(<span style="color:#888;font-weight:bold">int</span> arg) {<span style="color:#888;font-weight:bold">int</span> old = m; m = arg; <span style="color:#080;font-weight:bold">return</span> old; } <span style="color:#888">// function member
</span><span style="color:#888"></span>}

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  Myclass var;			<span style="color:#888">// creates a variable type Myclass
</span><span style="color:#888"></span>  var.m = <span style="color:#00d;font-weight:bold">6</span>;			<span style="color:#888">// ASSIGN value 6 to member
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> x = var.method(<span style="color:#00d;font-weight:bold">10</span>);	<span style="color:#888">// CALL function with argument 10
</span><span style="color:#888"></span>  cout &lt;&lt; var.m &lt;&lt; endl;	<span style="color:#888">// changed member from 6 to 10
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
10
</pre>
</div>
</div>
<div id="outline-container-headline-67" class="outline-3">
<h3 id="headline-67">
Interface and implementation
</h3>
<div id="outline-text-headline-67" class="outline-text-3">
<p>A class has an interface and an implementation.</p>
<p>
The interface is the part of the class declaration that users access directly.</p>
<p>
The implementation is the part accessed indirectly by the users through the interface.</p>
<p>
The public interface is defined with the label <code class="verbatim">public</code>, whereas the implementation with label <code class="verbatim">private</code>.
Class members are private by default.</p>
</div>
</div>
<div id="outline-container-headline-68" class="outline-3">
<h3 id="headline-68">
Structures
</h3>
<div id="outline-text-headline-68" class="outline-text-3">
<p>
Organize elements that a new type needs into a data structure.
It is a <span style="text-decoration: underline;">class</span> that <strong>only</strong> have <strong>public</strong> members.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Vector</span> {			<span style="color:#888">// defines a type: Vector
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> sz;			<span style="color:#888">// type element sz
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">double</span>* elem;			<span style="color:#888">// elem is a pointer
</span><span style="color:#888"></span>}

<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">vector_init</span>(Vector&amp;v, <span style="color:#888;font-weight:bold">int</span> s){ <span style="color:#888">// &amp; v is passed by non-const reference
</span><span style="color:#888"></span>  v.elem = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s];	<span style="color:#888">// new creates objects independent on the scope
</span><span style="color:#888"></span>  v.sz = s;			<span style="color:#888">// v&#39;s sz MEMBER gets the int value s
</span><span style="color:#888"></span>}

<span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">sum_squared</span>(<span style="color:#888;font-weight:bold">int</span> s)
<span style="color:#888">// sum the square of s first integers
</span><span style="color:#888"></span>{
  Vector v;			<span style="color:#888">// creates a Vector variable
</span><span style="color:#888"></span>  vector_init(v, s);		<span style="color:#888">// allocate s elements for f
</span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i=<span style="color:#00d;font-weight:bold">0</span>; i!=s; ++i)
    v.elem[i] = i*i;

  <span style="color:#888;font-weight:bold">double</span> sum = <span style="color:#00d;font-weight:bold">0</span>;
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i=<span style="color:#00d;font-weight:bold">0</span>; i!=s; ++i)
{
    sum += v.elem[i];
    cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;i &#34;</span> &lt;&lt; i &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; &#34;</span> &lt;&lt; sum &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;</span><span style="color:#04d;background-color:#fff0f0">\n</span><span style="color:#d20;background-color:#fff0f0">&#34;</span>;
}
    <span style="color:#080;font-weight:bold">return</span> sum;
}

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> ()
{
  cout &lt;&lt;  sum_squared(<span style="color:#00d;font-weight:bold">3</span>);
}</code></pre></div>
</div>
<table>
<tbody>
<tr>
<td>i</td>
<td class="align-right">0</td>
<td class="align-right">0</td>
</tr>
<tr>
<td>i</td>
<td class="align-right">1</td>
<td class="align-right">1</td>
</tr>
<tr>
<td>i</td>
<td class="align-right">2</td>
<td class="align-right">5</td>
</tr>
<tr>
<td>5</td>
<td class="align-right"></td>
<td class="align-right"></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-headline-69" class="outline-3">
<h3 id="headline-69">
Constructor
</h3>
<div id="outline-text-headline-69" class="outline-text-3">
<p>
Member function with <span style="text-decoration: underline;">same name</span> as its class is known as <span style="text-decoration: underline;">constructor</span>.
It is used to initialize an object of the class.
It is a function that runs when an instance (object) of the class is created.</p>
<p>
During the call of the constructor the memory resources for a class are acquired.</p>
<p>
The constructor arguments are the ones required to initialize an object.
Initialization occurs when a class is called with the constructor arguments been passed within <code class="verbatim">{}</code>.
Is the same as instantiating an object.</p>
<p>
The constructor has no return type.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Date</span> {
<span style="color:#080;font-weight:bold">public</span>:				<span style="color:#888">// accessible outside
</span><span style="color:#888"></span>  Date(<span style="color:#888;font-weight:bold">int</span> yy, <span style="color:#888;font-weight:bold">int</span> mm, <span style="color:#888;font-weight:bold">int</span> dd)
  {
    year = yy;
    month = mm;
    day = dd;
    }	<span style="color:#888">// constructor, initialize the class when the class is called with correct arguments
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> year;
  <span style="color:#888;font-weight:bold">int</span> month;
  <span style="color:#888;font-weight:bold">int</span> day;
}
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  Date today {<span style="color:#00d;font-weight:bold">1999</span>, <span style="color:#00d;font-weight:bold">12</span>, <span style="color:#00d;font-weight:bold">5</span>};	<span style="color:#888">// creates an object type Date, use {} to INITIALIZE (modern style)
</span><span style="color:#888"></span>  cout &lt;&lt; today.month;
}</code></pre></div>
</div>
<pre class="example">
12
</pre>
</div>
</div>
<div id="outline-container-headline-70" class="outline-3">
<h3 id="headline-70">
Functors
</h3>
<div id="outline-text-headline-70" class="outline-text-3">
<p>
Functors are function objects.
Use case: when you need to pass a function and its arguments as an argument to another routine.</p>
<p>
In a functor, the object operator <code class="verbatim">()</code> has been overload to act as a function call return value.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Square</span> {
  <span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">operator</span>()(<span style="color:#080;font-weight:bold">const</span> <span style="color:#888;font-weight:bold">double</span> x){ <span style="color:#888">// redefine operator () to return
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">return</span> x*x;
  }
};

<span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_square</span> (<span style="color:#080;font-weight:bold">auto</span> f, <span style="color:#888;font-weight:bold">double</span> x) {	<span style="color:#888">// function argument is a function type Square
</span><span style="color:#888"></span>  std::cout &lt;&lt; f(x);		<span style="color:#888">// function can be called here with ()
</span><span style="color:#888"></span>}

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  Square g;			<span style="color:#888">// instantiate g as a object with () returning the square
</span><span style="color:#888"></span>  print_square(g, <span style="color:#00d;font-weight:bold">2.91</span>);	<span style="color:#888">// passing the functor
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
8.4681
</pre>
</div>
</div>
<div id="outline-container-headline-71" class="outline-3">
<h3 id="headline-71">
Constant arguments in methods
</h3>
<div id="outline-text-headline-71" class="outline-text-3">
<p>
C++ class methods have implicit <code class="verbatim">this</code> parameter which comes before all explicit ones.
The <code class="verbatim">const</code> operator after the function arguments make the <code class="verbatim">this</code> parameter constant.
The method itself becomes &#34;constant&#34; meaning that it can only be used for member functions.</p>
<p>
The <code class="verbatim">const</code> in the argument list just means that the argument is immutable within the function scope.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">square_1</span> (<span style="color:#080;font-weight:bold">const</span> <span style="color:#888;font-weight:bold">double</span> value) {
  <span style="color:#080;font-weight:bold">return</span> value * value;
}

<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">math</span> {
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">double</span> square_2(<span style="color:#888;font-weight:bold">double</span> value) <span style="color:#080;font-weight:bold">const</span> { <span style="color:#888">// different position
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">return</span> value * value;
  }
  <span style="color:#888;font-weight:bold">double</span> var = <span style="color:#00d;font-weight:bold">10</span>;
      
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  std::cout &lt;&lt; square_1(<span style="color:#00d;font-weight:bold">10</span>) &lt;&lt; std::endl;
  math mymath;
  std::cout &lt;&lt; mymath.square_2(<span style="color:#00d;font-weight:bold">10</span>) &lt;&lt; std::endl;
  mymath.var = mymath.square_2(<span style="color:#00d;font-weight:bold">1</span>);
}</code></pre></div>
</div>
<pre class="example">
100
100
</pre>
</div>
</div>
<div id="outline-container-headline-72" class="outline-3">
<h3 id="headline-72">
Defining member function outside the class
</h3>
<div id="outline-text-headline-72" class="outline-text-3">
<p>
We can do that by using <code class="verbatim">class_name::member_name</code>.
Good to avoid long class declarations.</p>
</div>
</div>
<div id="outline-container-headline-73" class="outline-3">
<h3 id="headline-73">
Member initializer list
</h3>
<div id="outline-text-headline-73" class="outline-text-3">
<p>
To initialize member variables in a list format.
The notation <code class="verbatim">:year{y}, month{m}, day{d}</code> more directly express <span style="text-decoration: underline;">intent</span>  of just initialize class members.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Date</span> {
<span style="color:#080;font-weight:bold">public</span>:				<span style="color:#888">// accessible outside
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> year, month, day;
  Date(<span style="color:#888;font-weight:bold">int</span> y, <span style="color:#888;font-weight:bold">int</span> m, <span style="color:#888;font-weight:bold">int</span> d);	<span style="color:#888">// just DECLARING the constructor
</span><span style="color:#888"></span>};

Date::Date(<span style="color:#888;font-weight:bold">int</span> y, <span style="color:#888;font-weight:bold">int</span> m, <span style="color:#888;font-weight:bold">int</span> d) <span style="color:#888">// define the constructor
</span><span style="color:#888"></span>  :year{y}, month{m}, day{d} {}	<span style="color:#888">// initialize member variables with passed arguments
</span><span style="color:#888"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  Date today {<span style="color:#00d;font-weight:bold">1999</span>, <span style="color:#00d;font-weight:bold">12</span>, <span style="color:#00d;font-weight:bold">20</span>};	<span style="color:#888">// create an object
</span><span style="color:#888"></span>  cout &lt;&lt; today.day;
}</code></pre></div>
</div>
<pre class="example">
20
</pre>
<p>
Alternative to</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Date</span> {
<span style="color:#080;font-weight:bold">public</span>: <span style="color:#888">// accessible outside
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> year, month, day;
  Date(<span style="color:#888;font-weight:bold">int</span> y, <span style="color:#888;font-weight:bold">int</span> m, <span style="color:#888;font-weight:bold">int</span> d); <span style="color:#888">// just DECLARING the constructor
</span><span style="color:#888"></span>};

Date::Date(<span style="color:#888;font-weight:bold">int</span> y, <span style="color:#888;font-weight:bold">int</span> m, <span style="color:#888;font-weight:bold">int</span> d) { <span style="color:#888">// DEFINE the constructor for the class Date
</span><span style="color:#888"></span>  year = y; <span style="color:#888">// assign the arguments from the class call into the class members
</span><span style="color:#888"></span>  month = m;
  day = d;
};
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  Date today{<span style="color:#00d;font-weight:bold">1999</span>, <span style="color:#00d;font-weight:bold">12</span>, <span style="color:#00d;font-weight:bold">20</span>}; <span style="color:#888">// create an object
</span><span style="color:#888"></span>  cout &lt;&lt; today.day &lt;&lt; endl;
}</code></pre></div>
</div>
<pre class="example">
20
</pre>
</div>
</div>
<div id="outline-container-headline-74" class="outline-3">
<h3 id="headline-74">
Initialize members modern
</h3>
<div id="outline-text-headline-74" class="outline-text-3">
<p>
Initialize with the arguments <code class="verbatim">y,m and d</code> and directly assign them to the class member data <code class="verbatim">year, month, day</code>.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Date</span> {
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">int</span> year, month, day;
  Date (<span style="color:#888;font-weight:bold">int</span> y, <span style="color:#888;font-weight:bold">int</span> m, <span style="color:#888;font-weight:bold">int</span> d) : year(y), month(m), day(d) {}
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  Date today(<span style="color:#00d;font-weight:bold">1999</span>, <span style="color:#00d;font-weight:bold">12</span>, <span style="color:#00d;font-weight:bold">31</span>);
  std::cout &lt;&lt; today.day;
}</code></pre></div>
</div>
<pre class="example">
31
</pre>
</div>
</div>
<div id="outline-container-headline-75" class="outline-3">
<h3 id="headline-75">
Operator overloading
</h3>
<div id="outline-text-headline-75" class="outline-text-3">
<p>
Use it when we want to provide conventional notation for a type.
Notation for &#34;increment&#34; <code class="verbatim">++</code> or &#34;output&#34; <code class="verbatim">&lt;&lt;</code>
Usually not recommended, except when it makes a clear positive impact.</p>
</div>
</div>
<div id="outline-container-headline-76" class="outline-3">
<h3 id="headline-76">
Symbolic constants within classes
</h3>
<div id="outline-text-headline-76" class="outline-text-3">
<p>
Use the <code class="verbatim">static</code> to make sure there is only one copy of the value in the program, rather than one per object of the class.</p>
</div>
</div>
<div id="outline-container-headline-77" class="outline-3">
<h3 id="headline-77">
Class interface principles
</h3>
<div id="outline-text-headline-77" class="outline-text-3">
<ol>
<li>
<p>complete and minimal</p>
</li>
<li>
<p>provide constructors</p>
</li>
<li>
<p>support copying</p>
</li>
<li>
<p>provide argument checking</p>
</li>
<li>
<p>identify nonmodifying member functions</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-78" class="outline-3">
<h3 id="headline-78">
Enumerators
</h3>
<div id="outline-text-headline-78" class="outline-text-3">
<p>
Other kind of user defined type (UDT), analogous to classes.
Useful when we need a <span style="text-decoration: underline;">set of related named integer constants</span>.
Can be used to restrict the argument of a function or class, requiring it to be a specific type.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#080;font-weight:bold">enum</span> <span style="color:#b06;font-weight:bold">Month</span> {
  jan=<span style="color:#00d;font-weight:bold">1</span>, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
}

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  Month m = feb;		<span style="color:#888">// feb in Month scope
</span><span style="color:#888"></span>  cout &lt;&lt; m &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;</span><span style="color:#04d;background-color:#fff0f0">\n</span><span style="color:#d20;background-color:#fff0f0">&#34;</span>;
  <span style="color:#888">// Month m2 = 2;			// not ok.
</span><span style="color:#888"></span>  cout &lt;&lt; Month(<span style="color:#00d;font-weight:bold">5</span>);		<span style="color:#888">// convert int to month
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<table>
<tbody>
<tr>
<td class="align-right">2</td>
</tr>
<tr>
<td class="align-right">5</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-headline-79" class="outline-3">
<h3 id="headline-79">
Inheritance
</h3>
<div id="outline-text-headline-79" class="outline-text-3">
<div id="outline-container-headline-80" class="outline-4">
<h4 id="headline-80">
Definitionss
</h4>
<div id="outline-text-headline-80" class="outline-text-4">
<ol>
<li>
<p>derived class has <span style="text-decoration: underline;">all method and stored states</span> of its base class.</p>
</li>
<li>
<p>&#34;is-a&#34; relationship between classes.</p>
</li>
<li>
<p>a parent class may have interface for all method that any child class may benefit from.</p>
</li>
<li>
<p>use inheritance to pass to an object a set of methods with no particular relationship (&#34;grab-bag&#34; analogy) </p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-81" class="outline-2">
<h2 id="headline-81">
Vectors
</h2>
<div id="outline-text-headline-81" class="outline-text-2">
<div id="outline-container-headline-82" class="outline-3">
<h3 id="headline-82">
Prologue
</h3>
<div id="outline-text-headline-82" class="outline-text-3">
<p>Vectors are the most useful in the standard library (STL) <span style="text-decoration: underline;">container</span>.
It provides a sequence of elements of a <span style="text-decoration: underline;">given type</span>.</p>
<p>
Create a vector container from scratch is useful to understand concepts and C++ facilities such as template and exception.</p>
<p>
Memory management low level knowledge is the base for more complex high level ones, like data structures, algorithms and operating systems.</p>
</div>
</div>
<div id="outline-container-headline-83" class="outline-3">
<h3 id="headline-83">
Fixed size vector
</h3>
<div id="outline-text-headline-83" class="outline-text-3">
<p>
Vector object with only 2 elements.</p>
<p>
Problem:</p>
<ol>
<li>
<p>hard coded number of elements, no way to add another other elements</p>
</li>
</ol>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> size, elem_0, elem_1; <span style="color:#888">// 2 elements
</span><span style="color:#888"></span>};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> (){
  vector myvector; <span style="color:#888">// create an instance of the vector class
</span><span style="color:#888"></span>}</code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-84" class="outline-3">
<h3 id="headline-84">
Variable number of elements
</h3>
<div id="outline-text-headline-84" class="outline-text-3">
<ol>
<li>
<p>initialize vector class with vector size <code class="verbatim">s.</code></p>
</li>
<li>
<p>during initialization create an array with this size.</p>
<ol>
<li>
<p>when initializing the class data <code class="verbatim">elem</code> with <code class="verbatim">new</code> allocate memory for an array of double size <code class="verbatim">s</code>.</p>
</li>
<li>
<p>I put the <code class="verbatim">elem</code> declaration in the <code class="verbatim">public</code> scope so we can print from <code class="verbatim">main</code>.</p>
</li>
</ol>
</li>
<li>
<p>assign 0 to array elements.</p>
</li>
</ol>
<p>Problems:</p>
<ol>
<li>
<p>vector leaks memory.</p>
<ol>
<li>
<p>creating a vector with <code class="verbatim">vector myvector(5)</code> allocates memory.</p>
</li>
<li>
<p>we need to free the memory using delete after using the vector created, otherwise the memory will be unusable.</p>
</li>
</ol>
</li>
<li>
<p>need to assign each element value individually which is <span style="text-decoration: underline;">repetitive and error prone</span>.</p>
</li>
</ol>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">double</span> *elem; <span style="color:#888">// crete a pointer to elements (public so we can access from main)
</span><span style="color:#888"></span>  vector(<span style="color:#888;font-weight:bold">int</span> s)
      : sz{s},                <span style="color:#888">// constructor and initialize the member data
</span><span style="color:#888"></span>        elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} { <span style="color:#888">// new returns a pointer to the first element in
</span><span style="color:#888"></span>                              <span style="color:#888">// the array size s
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>; <span style="color:#888">// assign 0 to all elements in array size s
</span><span style="color:#888"></span>  }
  <span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">size</span>() <span style="color:#080;font-weight:bold">const</span> { <span style="color:#080;font-weight:bold">return</span> sz; } <span style="color:#888">// return vector size
</span><span style="color:#888"></span>};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> (){
  vector myvector{<span style="color:#00d;font-weight:bold">5</span>}; <span style="color:#888">// instantiate with the constructor paramenters
</span><span style="color:#888"></span>  std::cout &lt;&lt; myvector.size() &lt;&lt; std::endl;
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; myvector.size(); i++)
    std::cout &lt;&lt; myvector.elem[i] &lt;&lt; std::endl; <span style="color:#888">// print elements
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
5
0
0
0
0
0
</pre>
</div>
</div>
<div id="outline-container-headline-85" class="outline-3">
<h3 id="headline-85">
Avoiding memory leak
</h3>
<div id="outline-text-headline-85" class="outline-text-3">
<p>
The <code class="verbatim">new</code> operator gets memory from the <em>free store</em>.
It is good practice to return this memory after using it.</p>
<p>
When a C++ program starts, the compiler sets aside <em>code storage</em>, or <em>text storage</em>, memory and <em><em>static storage</em></em> for the globally defined variables.
It also sets aside memory for call functions, <em>stack storage</em> or <em>automatic storage</em>. 
The <em>free store</em>, or <em>heap</em>, is what is left to the system.
When <code class="verbatim">new</code> operator is called it makes this <em>free store</em> available to the program, memory leaks.</p>
<p>
Each vector creation &#34;leaks&#34; the <code class="verbatim">s</code> doubles allocated to the newly created vector.
Meaning that it leaked from the free store memory available in the system.
We can free the memory up by <code class="verbatim">delete[] myvector;</code> after using.</p>
<p>
Just deleting is not a good practice because it is not robust or reliable enough.</p>
</div>
</div>
<div id="outline-container-headline-86" class="outline-3">
<h3 id="headline-86">
Destructor
</h3>
<div id="outline-text-headline-86" class="outline-text-3">
<p>
The <em>destructor</em> is represented by calling the same constructor function with <code class="verbatim">~</code> in the front.
The constructor is called implicitly when an object class is created, instantiated, the <strong>destructor is called also implicitly when the object goes out of scope</strong>.</p>
<p>
When do we need a destructor? when a class acquires resources and must give it back once finished using it.
A vector class, for instance, acquires memory to store the vector elements.
Generally, if a class has pointer members or references it will need a destructor.</p>
<p>
When the destructor is called the elements <span style="text-decoration: underline;">pointed to</span> by the vector <code class="verbatim">elem</code> pointer will be deleted, <em>freed</em>.</p>
<p>
The standard library <code class="verbatim">vector</code> does that already.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">double</span> *elem; <span style="color:#888">// crete a pointer to elements (public so we can access from main)
</span><span style="color:#888"></span>  vector(<span style="color:#888;font-weight:bold">int</span> s)
      : sz{s}, <span style="color:#888">// constructor and initialize the member data
</span><span style="color:#888"></span>        elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {	<span style="color:#888">// new returns a pointer to the first element in the array size s 
</span><span style="color:#888"></span>   <span style="color:#080;font-weight:bold">for</span>(<span style="color:#888;font-weight:bold">int</span> i=<span style="color:#00d;font-weight:bold">0</span>; i&lt;s; i++) elem[i] = <span style="color:#00d;font-weight:bold">0</span>; <span style="color:#888">// assign 0 to all elements in array size s
</span><span style="color:#888"></span>  }

  <span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">size</span>() <span style="color:#080;font-weight:bold">const</span> { <span style="color:#080;font-weight:bold">return</span> sz; } <span style="color:#888">// return vector size
</span><span style="color:#888"></span>
  ~vector() {			<span style="color:#888">// destructor
</span><span style="color:#888"></span>   <span style="color:#080;font-weight:bold">delete</span>[] elem; 		<span style="color:#888">// free memmory
</span><span style="color:#888"></span>  }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> (){
  vector myvector{<span style="color:#00d;font-weight:bold">5</span>}; <span style="color:#888">// instantiate with the constructor paramenters
</span><span style="color:#888"></span>  std::cout &lt;&lt; myvector.size() &lt;&lt; std::endl;
  <span style="color:#080;font-weight:bold">for</span>(<span style="color:#888;font-weight:bold">int</span> i=<span style="color:#00d;font-weight:bold">0</span>; i&lt;myvector.size(); i++) std::cout &lt;&lt; myvector.elem[i] &lt;&lt; std::endl; <span style="color:#888">// print elements
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
5
0
0
0
0
0
</pre>
</div>
</div>
<div id="outline-container-headline-87" class="outline-3">
<h3 id="headline-87">
<code class="verbatim">get()</code> and <code class="verbatim">set()</code> methods
</h3>
<div id="outline-text-headline-87" class="outline-text-3">
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">double</span> *elem;
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }
  <span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">size</span>() { <span style="color:#080;font-weight:bold">return</span> sz; }
  ~vector() { <span style="color:#080;font-weight:bold">delete</span>[] elem; }
  <span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">get</span>(<span style="color:#888;font-weight:bold">int</span> n) { <span style="color:#080;font-weight:bold">return</span> elem[n]; }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">set</span>(<span style="color:#888;font-weight:bold">int</span> n, <span style="color:#888;font-weight:bold">double</span> v) { elem[n] = v; }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector myvector{<span style="color:#00d;font-weight:bold">5</span>}; <span style="color:#888">// instantiate with the constructor paramenters
</span><span style="color:#888"></span>  std::cout &lt;&lt; myvector.size() &lt;&lt; std::endl;
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; myvector.size(); i++)
    std::cout &lt;&lt; myvector.elem[i] &lt;&lt; std::endl; <span style="color:#888">// print elements
</span><span style="color:#888"></span>  myvector.set(<span style="color:#00d;font-weight:bold">3</span>, <span style="color:#00d;font-weight:bold">19</span>);
  std::cout &lt;&lt; myvector.get(<span style="color:#00d;font-weight:bold">3</span>) &lt;&lt; std::endl;
}</code></pre></div>
</div>
<pre class="example">
5
0
0
0
0
0
19
</pre>
</div>
</div>
<div id="outline-container-headline-88" class="outline-3">
<h3 id="headline-88">
Getting element&#39;s values
</h3>
<div id="outline-text-headline-88" class="outline-text-3">
<p>
We can use the <code class="verbatim">get()</code> method or the arrow <code class="verbatim">-&gt;</code> operator.</p>
<p>
All classes support the <code class="verbatim">-&gt;</code> operator to access a member via a pointer.
It can be used for data member and function members.
The <code class="verbatim">-&gt;</code> arrow is <span style="text-decoration: underline;">analogous</span> to <code class="verbatim">.</code> dot access but for pointers instead of variables.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;

<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">double</span> *elem;
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }
  <span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">size</span>() { <span style="color:#080;font-weight:bold">return</span> sz; }
  ~vector() { <span style="color:#080;font-weight:bold">delete</span>[] elem; }
  <span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">get</span>(<span style="color:#888;font-weight:bold">int</span> n) { <span style="color:#080;font-weight:bold">return</span> elem[n]; }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">set</span>(<span style="color:#888;font-weight:bold">int</span> n, <span style="color:#888;font-weight:bold">double</span> v) { elem[n] = v; }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector myvector{<span style="color:#00d;font-weight:bold">5</span>};
  myvector.set(<span style="color:#00d;font-weight:bold">3</span>, <span style="color:#00d;font-weight:bold">19</span>);
  std::cout &lt;&lt; myvector.get(<span style="color:#00d;font-weight:bold">3</span>) &lt;&lt; std::endl;	<span style="color:#888">// using get()
</span><span style="color:#888"></span>
  vector* p = <span style="color:#080;font-weight:bold">new</span> vector(<span style="color:#00d;font-weight:bold">4</span>);		<span style="color:#888">// p is a pointer to a vector created with new
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">double</span> d = p-&gt;get(<span style="color:#00d;font-weight:bold">3</span>);		<span style="color:#888">// -&gt; access the member function get() with the pointer
</span><span style="color:#888"></span>  std::cout &lt;&lt; d;
}</code></pre></div>
</div>
<pre class="example">
19
0
</pre>
</div>
</div>
<div id="outline-container-headline-89" class="outline-3">
<h3 id="headline-89">
Constructor with initializer list <code class="verbatim">{}</code>
</h3>
<div id="outline-text-headline-89" class="outline-text-3">
<p>
Instead of assigning value to each element individually we can pass an <span style="text-decoration: underline;">initilizer list</span> to the constructor with the element values.
The <code class="verbatim">{}</code> delimited list of a specific type is an object of the standard library <code class="verbatim">initialize_list&lt;T&gt;</code>.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;initializer_list&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
  <span style="color:#888;font-weight:bold">double</span> *elem;
<span style="color:#080;font-weight:bold">public</span>:
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }

  vector(std::initializer_list&lt;<span style="color:#888;font-weight:bold">double</span>&gt; lst)
      : sz(lst.size()), elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[sz]} {
    std::copy(lst.begin(), lst.end(), elem);
  }
  
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>() {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; i++) {std::cout &lt;&lt; elem[i] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;}
    std::cout &lt;&lt; std::endl;
  }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector vec1(<span style="color:#00d;font-weight:bold">5</span>);		<span style="color:#888">// () for element count
</span><span style="color:#888"></span>  vec1.print_vec();
  vector vec2{<span style="color:#00d;font-weight:bold">5</span>, <span style="color:#00d;font-weight:bold">2</span>, <span style="color:#00d;font-weight:bold">3</span>};		<span style="color:#888">// {} for element lists
</span><span style="color:#888"></span>  vec2.print_vec();
  vector vec3 = {<span style="color:#00d;font-weight:bold">11</span>, <span style="color:#00d;font-weight:bold">17</span>, <span style="color:#00d;font-weight:bold">19</span>};	<span style="color:#888">// using = is a clear way to pass the element list
</span><span style="color:#888"></span>  vec3.print_vec();
}</code></pre></div>
</div>
<pre class="example">
0, 0, 0, 0, 0, 
5, 2, 3, 
11, 17, 19, 
</pre>
<p>
Remarks:</p>
<ol>
<li>
<p>using standard library <code class="verbatim">initialize_list&lt;T&gt;</code> class to initialize a list of elements type <code class="verbatim">T</code> by passing it as argument to the constructor.</p>
</li>
<li>
<p>notice the initialization of <code class="verbatim">sz(lst.size())</code> uses <code class="verbatim">()</code> instead of <code class="verbatim">{}</code></p>
<ol>
<li>
<p>avoids the warning: <code class="verbatim">clang: Non-constant-expression cannot be narrowed from type &#39;std::initializer_list::size_type&#39; (aka &#39;unsigned long&#39;) to &#39;int&#39; in initializer list (fix available)</code></p>
</li>
</ol>
</li>
<li>
<p>the class has now two constructor options, one with the number of elements and the other with the elements values.</p>
</li>
<li>
<p><code class="verbatim">new</code> is used to allocate memory space not yet initialized, which is done in the next line</p>
</li>
<li>
<p>standard library <code class="verbatim">copy()</code> algorithm copies sequence specified by the first two arguments <code class="verbatim">lst.begin()</code> and <code class="verbatim">lst.end()</code> into the third argument <code class="verbatim">elem</code>.  </p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-90" class="outline-3">
<h3 id="headline-90">
Copying
</h3>
<div id="outline-text-headline-90" class="outline-text-3">
<div id="outline-container-headline-91" class="outline-4">
<h4 id="headline-91">
Definitionss
</h4>
<div id="outline-text-headline-91" class="outline-text-4">
<p>
When do we need a copy constructor?
A class that needs a destructor will most probably need a copy constructor and copy assignment.</p>
</div>
</div>
<div id="outline-container-headline-92" class="outline-4">
<h4 id="headline-92">
Standard copying behavior
</h4>
<div id="outline-text-headline-92" class="outline-text-4">
<p>
We are passing the elements of the vector through a pointer <code class="verbatim">elem</code>.
When we make a copy, we are copying the pointer.
This means that the copy also points to the same address as the original.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;

<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">double</span> *elem;
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }
  <span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">size</span>() { <span style="color:#080;font-weight:bold">return</span> sz; }
  <span style="color:#888">// ~vector() { delete[] elem; }
</span><span style="color:#888"></span>  vector(std::initializer_list&lt;<span style="color:#888;font-weight:bold">double</span>&gt; lst)
      : sz(lst.size()), elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[sz]} {
    std::copy(lst.begin(), lst.end(), elem);
  }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>() {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; i++) {std::cout &lt;&lt; elem[i] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;}
    std::cout &lt;&lt; std::endl;
  }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector vec1 = {<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">2</span>, <span style="color:#00d;font-weight:bold">3</span>};
  vec1.print_vec();
  vector vec2 = vec1;			<span style="color:#888">// make a copy
</span><span style="color:#888"></span>  vec1.elem[<span style="color:#00d;font-weight:bold">0</span>] = <span style="color:#00d;font-weight:bold">99</span>;				<span style="color:#888">// change first entry of VECTOR 1
</span><span style="color:#888"></span>  vec2.print_vec(); 
}</code></pre></div>
</div>
<pre class="example">
1, 2, 3, 
99, 2, 3, 
</pre>
<p>
This gives the error: <code class="verbatim">free(): double free detected in tcache 2</code> If we leave the destructor.
This error happens because the destructor for <code class="verbatim">vec1</code> is called then its elements are deleted to free up the memory.
However de destructor for <code class="verbatim">vec2</code> is also called and this time it does not encounter anything left to delete.</p>
<p>
If the destructor is commented out, it can run.
We observe that by changing <code class="verbatim">vec1</code> e also changed the elements of <code class="verbatim">vec2</code>, because they point to the same address.</p>
</div>
</div>
<div id="outline-container-headline-93" class="outline-4">
<h4 id="headline-93">
Copy constructor
</h4>
<div id="outline-text-headline-93" class="outline-text-4">
<p>
Initialization of class objects is always done by a constructor.
We call <span style="text-decoration: underline;">copy constructor</span> the one that take as argument <span style="text-decoration: underline;">a reference to the object from which to copy</span>, <code class="verbatim">vector(const vector&amp;)</code>.</p>
<p>
The operator <code class="verbatim">&amp;</code> is same used to create a reference object.
The <code class="verbatim">const</code> indicates that we don&#39;t want to change the reference (object that we are copying, the original).</p>
<p>
When we instantiate an object of the class by passing another object of the same class the <em>copy constructor</em> is called.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">double</span> *elem;
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }
  <span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">size</span>() { <span style="color:#080;font-weight:bold">return</span> sz; }
  ~vector() { <span style="color:#080;font-weight:bold">delete</span>[] elem; }
  vector(std::initializer_list&lt;<span style="color:#888;font-weight:bold">double</span>&gt; lst)
      : sz(lst.size()), elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[sz]} {
    std::copy(lst.begin(), lst.end(), elem);
  }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>() {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; i++) {std::cout &lt;&lt; elem[i] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;}
    std::cout &lt;&lt; std::endl;
  }

  vector(<span style="color:#080;font-weight:bold">const</span> vector&amp; arg) 		<span style="color:#888">// COPY CONSTRUCTOR
</span><span style="color:#888"></span>  : sz(arg.sz), elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[arg.sz]} <span style="color:#888">// allocates memory for the elements
</span><span style="color:#888"></span>  {
  std::copy(&amp;arg.elem[<span style="color:#00d;font-weight:bold">0</span>], &amp;arg.elem[sz], elem); <span style="color:#888">// arg.elem is a pointer to the first address of the vector
</span><span style="color:#888"></span>  }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector vec1 = {<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">2</span>, <span style="color:#00d;font-weight:bold">3</span>, <span style="color:#00d;font-weight:bold">12</span>, <span style="color:#00d;font-weight:bold">12</span>};
  vec1.print_vec();
  vector vec2 = vec1;			<span style="color:#888">// make a copy
</span><span style="color:#888"></span>  vec1.elem[<span style="color:#00d;font-weight:bold">0</span>] = <span style="color:#00d;font-weight:bold">99</span>;				<span style="color:#888">// change first entry of VECTOR 1
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;changed original!&#34;</span> &lt;&lt; std::endl;
  vec2.print_vec(); 
  vec1.print_vec();
}</code></pre></div>
</div>
<pre class="example">
1, 2, 3, 12, 12, 
changed original!
1, 2, 3, 12, 12, 
99, 2, 3, 12, 12, 
</pre>
<p>
Remarks:</p>
<ol>
<li>
<p>As expected now we have each vector in a separate memory slot.</p>
</li>
<li>
<p><code class="verbatim">&amp;arg.elem[sz]</code> returns the address of the last element of <code class="verbatim">arg.elem</code>, because the member data <code class="verbatim">elem</code> is a pointer.</p>
</li>
<li>
<p>changing the original vector does not affect the copy</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-94" class="outline-4">
<h4 id="headline-94">
Copy assignments constructor
</h4>
<div id="outline-text-headline-94" class="outline-text-4">
<p>
In the copy assignment we want to control the behavior of a simple assignment <code class="verbatim">vec1=vec2</code>.
This is done with another constructor <code class="verbatim">vector&amp; operator=(const vector&amp; rhs)</code>.
This constructor is called when an object of the class appears on the left side of an assignment expression.</p>
<p>
Default meaning of &#34;copy assignment&#34; is memberwise copy.
Without the proper handle of the assignment operation we are going to have 2 pointers pointing to the same memory location.
Assignment will cause a double deletion and memory leak.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">double</span> *elem;
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }
  <span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">size</span>() { <span style="color:#080;font-weight:bold">return</span> sz; }
  ~vector() { <span style="color:#080;font-weight:bold">delete</span>[] elem; }
  vector(std::initializer_list&lt;<span style="color:#888;font-weight:bold">double</span>&gt; lst)
      : sz(lst.size()), elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[sz]} {
    std::copy(lst.begin(), lst.end(), elem);
  }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>(<span style="color:#888;font-weight:bold">int</span> vec_id) {
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;vector &#34;</span> &lt;&lt; vec_id &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; = [&#34;</span>;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; i++) {
      std::cout &lt;&lt; elem[i] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;
    }
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;]&#34;</span> &lt;&lt; std::endl;
  }
  vector&amp; <span style="color:#080;font-weight:bold">operator</span>=(<span style="color:#080;font-weight:bold">const</span> vector&amp; rhs){ <span style="color:#888">// COPY ASSIGNMENT constructor
</span><span style="color:#888"></span>    <span style="color:#888;font-weight:bold">double</span> *p = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[rhs.sz];     <span style="color:#888">// allocate memory for the copy
</span><span style="color:#888"></span>    std::copy(&amp;rhs.elem[<span style="color:#00d;font-weight:bold">0</span>], &amp;rhs.elem[sz], p);     <span style="color:#888">// beg, end, destination
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">delete</span>[] elem;			<span style="color:#888">// dealocate old
</span><span style="color:#888"></span>    elem = p;				<span style="color:#888">// new elem
</span><span style="color:#888"></span>    sz = rhs.sz;
    <span style="color:#080;font-weight:bold">return</span> *<span style="color:#080;font-weight:bold">this</span>;		<span style="color:#888">//  return self reference
</span><span style="color:#888"></span>  }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector vec = {<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">2</span>, <span style="color:#00d;font-weight:bold">3</span>};
  vec.print_vec(<span style="color:#00d;font-weight:bold">1</span>);
  vector vec_copy(<span style="color:#00d;font-weight:bold">3</span>);
  vec_copy = vec;	<span style="color:#888">// ASSIGNMENT COPY
</span><span style="color:#888"></span>  vec_copy.print_vec(<span style="color:#00d;font-weight:bold">2</span>);
  vec_copy.elem[<span style="color:#00d;font-weight:bold">0</span>] = <span style="color:#00d;font-weight:bold">1000</span>;		<span style="color:#888">// change copy
</span><span style="color:#888"></span>  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;changed copy!&#34;</span> &lt;&lt; std::endl;
  vec.print_vec(<span style="color:#00d;font-weight:bold">1</span>);
  vec_copy.print_vec(<span style="color:#00d;font-weight:bold">2</span>);
}</code></pre></div>
</div>
<pre class="example">
vector 1 = [1, 2, 3, ]
vector 2 = [1, 2, 3, ]
changed copy!
vector 1 = [1, 2, 3, ]
vector 2 = [1000, 2, 3, ]
</pre>
<p>
Remarks:</p>
<ol>
<li>
<p><code class="verbatim">vector&amp; rhs</code> means that the function gets a reference</p>
</li>
<li>
<p><code class="verbatim">copy(rhs.elem, rhs.elem.sz, p);</code> which is in the book does not work</p>
<ol>
<li>
<p>gives an error: <code class="verbatim">request for member ‘sz’ in ‘rhs.vector::elem’, which is of non-class type ‘double* const’</code></p>
</li>
<li>
<p>solved by manually get the memory address of the first and last member</p>
</li>
</ol>
</li>
<li>
<p><code class="verbatim">return *this</code></p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-95" class="outline-4">
<h4 id="headline-95">
Shallow and memberwise copy
</h4>
<div id="outline-text-headline-95" class="outline-text-4">
<p>
A shallow copy means copying <span style="text-decoration: underline;">just the pointer (or reference)</span>.
Now two pointers point to the same object.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> *ptr = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">int</span>{<span style="color:#00d;font-weight:bold">2</span>};
  <span style="color:#888;font-weight:bold">int</span> *new_ptr = ptr;		<span style="color:#888">// copy with assignment operator
</span><span style="color:#888"></span>  ,*ptr = <span style="color:#00d;font-weight:bold">8</span>;
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;old pointer content: &#34;</span> &lt;&lt; *ptr &lt;&lt; std::endl;
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;new pointer content: &#34;</span> &lt;&lt; *new_ptr;
}</code></pre></div>
</div>
<pre class="example">
old pointer content: 8
new pointer content: 8
</pre>
<p>
A deep copy on the other hand refers to copying the <strong>content</strong>, what the pointer points to.
Now two pointers refer to two distinct objects.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  <span style="color:#888;font-weight:bold">int</span> *ptr = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">int</span>{<span style="color:#00d;font-weight:bold">22</span>}; 
  <span style="color:#888;font-weight:bold">int</span> *new_ptr = <span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">int</span>{*ptr}; 	<span style="color:#888">// creates new pointer with same content as ptr
</span><span style="color:#888"></span>  *ptr = <span style="color:#00d;font-weight:bold">88</span>;
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;old pointer content: &#34;</span> &lt;&lt; *ptr &lt;&lt; std::endl;
  std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;new pointer content: &#34;</span> &lt;&lt; *new_ptr;
}</code></pre></div>
</div>
<pre class="example">
old pointer content: 88
new pointer content: 22
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-96" class="outline-3">
<h3 id="headline-96">
Move constructor
</h3>
<div id="outline-text-headline-96" class="outline-text-3">
<div id="outline-container-headline-97" class="outline-4">
<h4 id="headline-97">
Definitions
</h4>
<div id="outline-text-headline-97" class="outline-text-4">
<p>When to use a move constructor?
A class that needs a destructor will probably need a move constructor and move assignment.
If a vector has a lot of elements copying it is expensive.</p>
</div>
</div>
<div id="outline-container-headline-98" class="outline-4">
<h4 id="headline-98">
Move constructor and assignment
</h4>
<div id="outline-text-headline-98" class="outline-text-4">
<p>
The move constructor uses the &#34;rvalue reference&#34; <code class="verbatim">&amp;&amp;</code>, <code class="verbatim">vector(vector&amp;&amp; a);</code>.
This operator is used to <span style="text-decoration: underline;">define move operations.</span></p>
<p>
The operator will modify the source, therefore the argument of the constructor is not constant.
The modification is to make the source empty.</p>
<p>
The advantage of moving instead of copying is to move around information cheaply.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
<span style="color:#080;font-weight:bold">public</span>:
  <span style="color:#888;font-weight:bold">double</span> *elem;
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }
  <span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">size</span>() { <span style="color:#080;font-weight:bold">return</span> sz; }
  ~vector() { <span style="color:#080;font-weight:bold">delete</span>[] elem; }
  vector(std::initializer_list&lt;<span style="color:#888;font-weight:bold">double</span>&gt; lst)
      : sz(lst.size()), elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[sz]} {
    std::copy(lst.begin(), lst.end(), elem);
  }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>(<span style="color:#888;font-weight:bold">int</span> vec_id) {
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;vector &#34;</span> &lt;&lt; vec_id &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; = [&#34;</span>;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; i++) {
      std::cout &lt;&lt; elem[i] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;
    }
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;]&#34;</span> &lt;&lt; std::endl;
  }
  <span style="color:#888">// move constructor
</span><span style="color:#888"></span>  vector(vector&amp;&amp; a)
  : sz{a.sz}, elem{a.elem} {	<span style="color:#888">// copy a and elem
</span><span style="color:#888"></span>    a.sz = <span style="color:#00d;font-weight:bold">0</span>;			<span style="color:#888">// modify source (a, rvalue)
</span><span style="color:#888"></span>    a.elem = <span style="color:#080;font-weight:bold">nullptr</span>;		<span style="color:#888">// EMPTY VECTOR!
</span><span style="color:#888"></span>  }
  <span style="color:#888">// move assignment
</span><span style="color:#888"></span>  vector &amp;<span style="color:#080;font-weight:bold">operator</span>=(vector&amp;&amp; a){
  <span style="color:#080;font-weight:bold">delete</span>[] elem;		<span style="color:#888">// dealocate OLD SPCAE
</span><span style="color:#888"></span>  elem = a.elem;		<span style="color:#888">// COPY from rvalue return
</span><span style="color:#888"></span>  sz = a.sz;
  a.elem = <span style="color:#080;font-weight:bold">nullptr</span>;		<span style="color:#888">// delete rvalue return from memory
</span><span style="color:#888"></span>  a.sz = <span style="color:#00d;font-weight:bold">0</span>;
  <span style="color:#080;font-weight:bold">return</span> *<span style="color:#080;font-weight:bold">this</span>;			<span style="color:#888">// SELFR REFERENCE
</span><span style="color:#888"></span>  }
};

vector <span style="color:#06b;font-weight:bold">use</span>(<span style="color:#888;font-weight:bold">double</span> value) {
  vector res(<span style="color:#00d;font-weight:bold">10</span>);
  res.elem[<span style="color:#00d;font-weight:bold">0</span>] = value;
  <span style="color:#080;font-weight:bold">return</span> res;
}

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector vec = use(<span style="color:#00d;font-weight:bold">99</span>);		<span style="color:#888">// get the return and copy into vec
</span><span style="color:#888"></span>  vec.print_vec(<span style="color:#00d;font-weight:bold">1</span>);
  vector vec2(<span style="color:#00d;font-weight:bold">2</span>);		<span style="color:#888">// orignal has 2 elements
</span><span style="color:#888"></span>  vec2 = use(<span style="color:#00d;font-weight:bold">11</span>);			<span style="color:#888">// move assignment
</span><span style="color:#888"></span>  vec2.print_vec(<span style="color:#00d;font-weight:bold">2</span>);
}</code></pre></div>
</div>
<pre class="example">
vector 1 = [99, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]
vector 2 = [11, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]
</pre>
<p>
Remarks:</p>
<ol>
<li>
<p>move operator does not take <code class="verbatim">const</code> arguments.</p>
</li>
<li>
<p>move construct is implicitly used when <code class="verbatim">return</code> is called.</p>
<ol>
<li>
<p>instead of copying the return to <code class="verbatim">vec</code>, we just move it.</p>
</li>
</ol>
</li>
<li>
<p>the function call <code class="verbatim">use()</code> is an &#34;rvalue&#34;.</p>
<ol>
<li>
<p>when a &#34;rvalue&#34;is passed to the constructor it gets its reference.</p>
</li>
</ol>
</li>
<li>
<p>the move constructor copies the paramenters from the rvalue return and delete it.</p>
</li>
<li>
<p>the move assignment first deletes the original space,</p>
<ol>
<li>
<p>then it copies the rvalue elements and size;</p>
</li>
<li>
<p>deletes the rvalue after it was copied;</p>
</li>
<li>
<p>returns a self reference;</p>
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-99" class="outline-4">
<h4 id="headline-99">
Move constructor importance
</h4>
<div id="outline-text-headline-99" class="outline-text-4">
<p>We use it so we don&#39;t have to deal with pointers or references to get large amount of information from a function.</p>
<p>
Without them, we would have to:</p>
<ol>
<li>
<p>create a vector in the function call and return it as a pointer;</p>
</li>
<li>
<p>use the vector and then delete it; (not ideal, better handle object creation automatically)</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-100" class="outline-3">
<h3 id="headline-100">
<span class="todo">TODO</span>
Default constructor
</h3>
<div id="outline-text-headline-100" class="outline-text-3">
<p>Used when we want to make an object instance without specifying an initializer, <code class="verbatim">vector{}</code>.</p>
<p>
Useful when we want to pass an object of a class into a standard library vector, for instance <code class="verbatim">vector &lt;vector&lt;int&gt;&gt; vec(10);</code> means vector of vector.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">template</span> &lt;<span style="color:#080;font-weight:bold">typename</span> T&gt; <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
  T *elem; <span style="color:#888">// pointer to elements
</span><span style="color:#888"></span><span style="color:#888;font-weight:bold">int</span> space; <span style="color:#888">// size+free space
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">public</span>:
vector() : sz{<span style="color:#00d;font-weight:bold">0</span>}, elem{<span style="color:#080;font-weight:bold">nullptr</span>}, space{<span style="color:#00d;font-weight:bold">0</span>} {} <span style="color:#888">// default constructor
</span><span style="color:#888"></span>};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
vector&lt;<span style="color:#888;font-weight:bold">int</span>&gt; vec_default;		<span style="color:#888">// default init
</span><span style="color:#888"></span>}</code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-101" class="outline-3">
<h3 id="headline-101">
<span class="todo">TODO</span>
Explicit constructor
</h3>
<div id="outline-text-headline-101" class="outline-text-3">
<p>The speficier <code class="verbatim">explicit</code> for constructor specify that the constructor can only be invoked with <code class="verbatim">{}</code> or <code class="verbatim">()</code>.
It does not accept <code class="verbatim">=</code> which is better to use only for assignments.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">template</span> &lt;<span style="color:#080;font-weight:bold">typename</span> T&gt; <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
  T *elem; <span style="color:#888">// pointer to elements
</span><span style="color:#888"></span><span style="color:#888;font-weight:bold">int</span> space; <span style="color:#888">// size+free space
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">public</span>:
<span style="color:#080;font-weight:bold">explicit</span> vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> T[s]}, space{s} {
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; ++i)
    elem[i] = <span style="color:#00d;font-weight:bold">0</span>;		<span style="color:#888">// construct with just size, elements 0
</span><span style="color:#888"></span>}
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
vector&lt;<span style="color:#888;font-weight:bold">double</span>&gt; vec_withsize(<span style="color:#00d;font-weight:bold">4</span>);		<span style="color:#888">// initializing with size
</span><span style="color:#888"></span>}</code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-102" class="outline-3">
<h3 id="headline-102">
Access to vector elements
</h3>
<div id="outline-text-headline-102" class="outline-text-3">
<div id="outline-container-headline-103" class="outline-4">
<h4 id="headline-103">
Motivation
</h4>
<div id="outline-text-headline-103" class="outline-text-4">
<p>
Alternative to &#34;verbose&#34; syntax of <code class="verbatim">get()</code> and <code class="verbatim">set()</code>.
Use the math subscript notation: <code class="verbatim">v[i].</code></p>
</div>
</div>
<div id="outline-container-headline-104" class="outline-4">
<h4 id="headline-104">
Member function <code class="verbatim">operator[]</code>
</h4>
<div id="outline-text-headline-104" class="outline-text-4">
<p>
Just defining a member function and return the element value referent to the index allows an equivalent to <code class="verbatim">get()</code>.
But it does not allows changing the element by using an assignment.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
  <span style="color:#888;font-weight:bold">double</span> *elem;
<span style="color:#080;font-weight:bold">public</span>:
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>(<span style="color:#888;font-weight:bold">int</span> vec_id) {
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;vector &#34;</span> &lt;&lt; vec_id &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; = [&#34;</span>;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; i++) {
      std::cout &lt;&lt; elem[i] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;
    }
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;]&#34;</span> &lt;&lt; std::endl;
  }
  <span style="color:#888;font-weight:bold">double</span> <span style="color:#080;font-weight:bold">operator</span>[](<span style="color:#888;font-weight:bold">int</span> n) { <span style="color:#080;font-weight:bold">return</span> elem[n]; }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector v{<span style="color:#00d;font-weight:bold">10</span>};
  v.print_vec(<span style="color:#00d;font-weight:bold">1</span>);
  std::cout&lt;&lt; v[<span style="color:#00d;font-weight:bold">0</span>]; 
  <span style="color:#888">// v[0] = 9;// ERROR! lvalue required as left operand of assignment
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<div id="outline-container-headline-105" class="outline-4">
<h4 id="headline-105">
Return pointer to elements
</h4>
<div id="outline-text-headline-105" class="outline-text-4">
<p>
To return pointer we use the dereference operator <code class="verbatim">*</code> in the function return type so it returns a pointer.
In the return statement we use the &#34;address of&#34; operator to get the address of the member.</p>
<p>
When we call <code class="verbatim">v[i]</code> we are in fact calling the member function <code class="verbatim">v.operator[]()</code>. </p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;ostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
  <span style="color:#888;font-weight:bold">double</span>* elem;
<span style="color:#080;font-weight:bold">public</span>:
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>(<span style="color:#888;font-weight:bold">int</span> vec_id) {
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;vector &#34;</span> &lt;&lt; vec_id &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; = [&#34;</span>;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; i++) {
      std::cout &lt;&lt; elem[i] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;
    }
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;]&#34;</span> &lt;&lt; std::endl;
  }
  <span style="color:#888;font-weight:bold">double</span>* <span style="color:#080;font-weight:bold">operator</span>[](<span style="color:#888;font-weight:bold">int</span> n) { <span style="color:#080;font-weight:bold">return</span> &amp;elem[n]; }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector v{<span style="color:#00d;font-weight:bold">10</span>};
  v.print_vec(<span style="color:#00d;font-weight:bold">1</span>);
  std::cout&lt;&lt; v[<span style="color:#00d;font-weight:bold">0</span>] &lt;&lt; std::endl;<span style="color:#888">// pointer address
</span><span style="color:#888"></span>  std::cout&lt;&lt; *v[<span style="color:#00d;font-weight:bold">0</span>] &lt;&lt; std::endl;<span style="color:#888">// * gets the content of the pointer
</span><span style="color:#888"></span>  <span style="color:#888">// v[0] = 1;	// error! v[0] returns a pointer to element 0
</span><span style="color:#888"></span>  *v[<span style="color:#00d;font-weight:bold">0</span>] = <span style="color:#00d;font-weight:bold">1</span>; 	<span style="color:#888">// we need to use the dereference to change the element value
</span><span style="color:#888"></span>  v.print_vec(<span style="color:#00d;font-weight:bold">2</span>);
}</code></pre></div>
</div>
<pre class="example">
vector 1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]
0x5578e704aeb0
0
vector 2 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]
</pre>
<p>
Remarks:</p>
<ol>
<li>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-106" class="outline-4">
<h4 id="headline-106">
Return a reference to elements
</h4>
<div id="outline-text-headline-106" class="outline-text-4">
<p>Now, instead of returning a pointer we return a reference with <code class="verbatim">double&amp;</code>.
With a reference we can change the element value without the need to use the dereference <code class="verbatim">*</code> operator to get the pointer value.</p>
<p>
This is the conventional implementation.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
  <span style="color:#888;font-weight:bold">double</span>* elem;
<span style="color:#080;font-weight:bold">public</span>:
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>(<span style="color:#888;font-weight:bold">int</span> vec_id) {
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;vector &#34;</span> &lt;&lt; vec_id &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; = [&#34;</span>;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; i++) {
      std::cout &lt;&lt; elem[i] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;
    }
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;]&#34;</span> &lt;&lt; std::endl;
  }
  <span style="color:#888;font-weight:bold">double</span>&amp; <span style="color:#080;font-weight:bold">operator</span>[](<span style="color:#888;font-weight:bold">int</span> n) {
    <span style="color:#080;font-weight:bold">return</span> elem[n]; <span style="color:#888">// returns reference
</span><span style="color:#888"></span>  }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector v{<span style="color:#00d;font-weight:bold">10</span>};
  v.print_vec(<span style="color:#00d;font-weight:bold">1</span>);
  v[<span style="color:#00d;font-weight:bold">0</span>] = <span style="color:#00d;font-weight:bold">1</span>; <span style="color:#888">// we can change the value of the reference
</span><span style="color:#888"></span>  v.print_vec(<span style="color:#00d;font-weight:bold">2</span>);
}</code></pre></div>
</div>
<pre class="example">
vector 1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]
vector 2 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]
</pre>
<p>
Remarks:</p>
<ol>
<li>
<p>when we call the subscript operator <code class="verbatim">[]</code> we could potentially change the vector.</p>
<ol>
<li>
<p>solution is to make this member function <code class="verbatim">const</code></p>
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-107" class="outline-4">
<h4 id="headline-107">
<code class="verbatim">const</code> member function
</h4>
<div id="outline-text-headline-107" class="outline-text-4">
<p>
Used so when we try to change a constant vector it blocks the operation.
The syntax is to add <code class="verbatim">const</code> after the function parameters <code class="verbatim">double operator[](int n) const;</code>.</p>
<p>
Vectors are often passed as constant objects, so the <code class="verbatim">operator[]() const</code> is an essential part.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
  <span style="color:#888;font-weight:bold">double</span>* elem;
<span style="color:#080;font-weight:bold">public</span>:
  vector(<span style="color:#888;font-weight:bold">int</span> s) : sz{s}, elem{<span style="color:#080;font-weight:bold">new</span> <span style="color:#888;font-weight:bold">double</span>[s]} {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; s; i++)
      elem[i] = <span style="color:#00d;font-weight:bold">0</span>;
  }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>(<span style="color:#888;font-weight:bold">int</span> vec_id) {
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;vector &#34;</span> &lt;&lt; vec_id &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; = [&#34;</span>;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; i++) {
      std::cout &lt;&lt; elem[i] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;
    }
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;]&#34;</span> &lt;&lt; std::endl;
  }
  <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">print_vec</span>(<span style="color:#888;font-weight:bold">int</span> vec_id) <span style="color:#080;font-weight:bold">const</span> {
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;vector &#34;</span> &lt;&lt; vec_id &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34; = [&#34;</span>;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#888;font-weight:bold">int</span> i = <span style="color:#00d;font-weight:bold">0</span>; i &lt; sz; i++) {
      std::cout &lt;&lt; elem[i] &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;, &#34;</span>;
    }
    std::cout &lt;&lt; <span style="color:#d20;background-color:#fff0f0">&#34;]&#34;</span> &lt;&lt; std::endl;
  }
  <span style="color:#888;font-weight:bold">double</span>&amp; <span style="color:#080;font-weight:bold">operator</span>[](<span style="color:#888;font-weight:bold">int</span> n) {
    <span style="color:#080;font-weight:bold">return</span> elem[n]; <span style="color:#888">// returns reference
</span><span style="color:#888"></span>  }
  <span style="color:#888;font-weight:bold">double</span> <span style="color:#080;font-weight:bold">operator</span>[](<span style="color:#888;font-weight:bold">int</span> n) <span style="color:#080;font-weight:bold">const</span> {
    <span style="color:#080;font-weight:bold">return</span> elem[n]; <span style="color:#888">// returns reference
</span><span style="color:#888"></span>  }
};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
  vector v{<span style="color:#00d;font-weight:bold">10</span>};
  v[<span style="color:#00d;font-weight:bold">0</span>] = <span style="color:#00d;font-weight:bold">1</span>; <span style="color:#888">// regular operator[]
</span><span style="color:#888"></span>  v.print_vec(<span style="color:#00d;font-weight:bold">2</span>);

  <span style="color:#080;font-weight:bold">const</span> vector v2{<span style="color:#00d;font-weight:bold">5</span>}; <span style="color:#888">// constant vector
</span><span style="color:#888"></span>  <span style="color:#888">// v2[0] = 9;	      // error! lvalue required as left operand of assignment
</span><span style="color:#888"></span>  v2.print_vec(<span style="color:#00d;font-weight:bold">3</span>);
  <span style="color:#888">// v2[0] = 1; // error! lvalue required as left operand of assignment
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<p>
Remarks:</p>
<ol>
<li>
<p>when a <code class="verbatim">const vector</code> is passed to the non const <code class="verbatim">operator[]</code></p>
<ol>
<li>
<p>we get an error because the lvalue is <code class="verbatim">const</code> in a function that is not</p>
</li>
<li>
<p>the function could potentially change the <code class="verbatim">const</code> value</p>
</li>
</ol>
</li>
<li>
<p>when after introducing a <code class="verbatim">operator[] const</code></p>
<ol>
<li>
<p>we try to change the <code class="verbatim">const</code> vector with the subscript operator we get an error</p>
</li>
<li>
<p>the <code class="verbatim">operator[] const</code> <span style="text-decoration: underline;">does not return a reference</span> <code class="verbatim">double&amp;</code> it returns a regular <code class="verbatim">double</code> <span style="text-decoration: underline;">value</span>!</p>
</li>
<li>
<p>can be used just to print the <code class="verbatim">const</code> vector elements</p>
</li>
<li>
<p>could instead return <code class="verbatim">const double&amp;</code> reference!</p>
<ol>
<li>
<p><span style="text-decoration: underline;">no point in returning a reference for a small object!</span></p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>to print the <code class="verbatim">const</code> vector a <code class="verbatim">print_vec() const</code> was required!</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-108" class="outline-3">
<h3 id="headline-108">
Arrays
</h3>
<div id="outline-text-headline-108" class="outline-text-3">
<div id="outline-container-headline-109" class="outline-4">
<h4 id="headline-109">
Definition
</h4>
<div id="outline-text-headline-109" class="outline-text-4">
<p>Sequence of objects allocated on free storage.
Homogeneous and allocated in a contiguous form.</p>
<p>
Prefer vectors instead of arrays.
Because:</p>
<ol>
<li>
<p>arrays don&#39;t know their own size</p>
<ol>
<li>
<p>keeping track of array bounds at compile time is impossible</p>
</li>
</ol>
</li>
<li>
<p>member arrays are hard to initialize</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-110" class="outline-3">
<h3 id="headline-110">
Vector conclusion
</h3>
<div id="outline-text-headline-110" class="outline-text-3">
<p>
The vector class can:</p>
<ol>
<li>
<p>create vectors (objects of the class) of double elements</p>
</li>
<li>
<p>create vectors with any number of elements</p>
</li>
<li>
<p>copy vectors using assignment and initialization</p>
</li>
<li>
<p>release memory reliably after going out of scope</p>
</li>
<li>
<p>access vector using conventional subscript notations on right-hand side and left-hand side of assignment</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-111" class="outline-3">
<h3 id="headline-111">
Problems still to be solved
</h3>
<div id="outline-text-headline-111" class="outline-text-3">
<ol>
<li>
<p>how to change the size of the vector?</p>
</li>
<li>
<p>how catch and report out-of-range vector element access?</p>
</li>
<li>
<p>how to specify the <span style="text-decoration: underline;">element type</span> of a vector <span style="text-decoration: underline;">as an argument</span>?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-112" class="outline-2">
<h2 id="headline-112">
Templates
</h2>
<div id="outline-text-headline-112" class="outline-text-2">
<div id="outline-container-headline-113" class="outline-3">
<h3 id="headline-113">
Definitions
</h3>
<div id="outline-text-headline-113" class="outline-text-3">
<div id="outline-container-headline-114" class="outline-4">
<h4 id="headline-114">
What is a template?
</h4>
<div id="outline-text-headline-114" class="outline-text-4">
<p>
<span style="text-decoration: underline;">A template is mechanisms that allows to <em>use types as parameters</em> for a class of function.</span>
The compiler generates a specific class or function when we provide a specific type as argument.</p>
<p>
Instead of creating a vector with <code class="verbatim">double</code> elements, what if we want <code class="verbatim">Date</code> elements of a specific user-defined type?</p>
</div>
</div>
<div id="outline-container-headline-115" class="outline-4">
<h4 id="headline-115">
What is a container?
</h4>
<div id="outline-text-headline-115" class="outline-text-4">
<p>
Containers are entities that store data.</p>
<p>
There are many kinds of containers.
For instance, <code class="verbatim">vector</code>, <code class="verbatim">string</code>, <code class="verbatim">list</code> and etc. </p>
<p>
At the memory level all objects are fixed in size and there are no types.
Containers with types and flexible size are provided by a programming language facility.
This allows flexibility and convenience.</p>
</div>
</div>
<div id="outline-container-headline-116" class="outline-4">
<h4 id="headline-116">
What is template instantiation?
</h4>
<div id="outline-text-headline-116" class="outline-text-4">
<p>The process of generating a class from a class template.
Also known as specialization.
This process is done by the compiler.</p>
</div>
</div>
<div id="outline-container-headline-117" class="outline-4">
<h4 id="headline-117">
What is generic programming?
</h4>
<div id="outline-text-headline-117" class="outline-text-4">
<p>Code that works with a variety of types.
The template feature allows generic programming.</p>
</div>
</div>
<div id="outline-container-headline-118" class="outline-4">
<h4 id="headline-118">
What is parametric polymorphism?
</h4>
<div id="outline-text-headline-118" class="outline-text-4">
<p>Form of generic programming that relies on explicit template parameters.</p>
<p>
Different from polymorphism from object-oriented programming.</p>
</div>
</div>
<div id="outline-container-headline-119" class="outline-4">
<h4 id="headline-119">
Why put template definition in header files?
</h4>
<div id="outline-text-headline-119" class="outline-text-4">
<p>
The compiler requires that a template must be fully defined wherever it is used, all member functions and all template functions.</p>
</div>
</div>
<div id="outline-container-headline-120" class="outline-4">
<h4 id="headline-120">
What is a concept?
</h4>
<div id="outline-text-headline-120" class="outline-text-4">
<p>
A set of requirements on a template argument.</p>
<p>
For instance, a vector requires that its elements can be copied, moved and so on.</p>
<p>
A concept is a type predicate, which means a compile-time-evaluated function that return <code class="verbatim">true</code> if type argument has the properties required by the concept.</p>
<p>
Example for C++14 or more:</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#080;font-weight:bold">template</span>&lt;<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">T</span>&gt;
<span style="color:#080;font-weight:bold">requires</span> Element&lt;T&gt;()		<span style="color:#888">// such that T is an Element
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {};</code></pre></div>
</div>
<p>
which is equivalent todo</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#080;font-weight:bold">template</span>&lt;Element T&gt;
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {};</code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-121" class="outline-3">
<h3 id="headline-121">
<span class="todo">TODO</span>
Changing size
</h3>
</div>
<div id="outline-container-headline-122" class="outline-3">
<h3 id="headline-122">
Creating Templates
</h3>
<div id="outline-text-headline-122" class="outline-text-3">
<p>
We use the directive <code class="verbatim">template&lt;typename T&gt;</code> before our class creation to get a type as parameter when instantiating the class.
One can also use <code class="verbatim">template&lt;class T&gt;, which seems clearer</code>.
The <code class="verbatim">T</code> is specific type passed in <code class="verbatim">vector&lt;TYPE&gt;</code> when creating an objects.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">template</span> &lt;<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">T</span>&gt; <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">vector</span> {
  <span style="color:#888;font-weight:bold">int</span> sz;
  T *elem; <span style="color:#888">// pointer to elements
</span><span style="color:#888"></span>  <span style="color:#888;font-weight:bold">int</span> space; <span style="color:#888">// size+free space
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">public</span>:
  vector() : sz{<span style="color:#00d;font-weight:bold">0</span>}, elem{<span style="color:#080;font-weight:bold">nullptr</span>}, space{<span style="color:#00d;font-weight:bold">0</span>} {} <span style="color:#888">// default constructor
</span><span style="color:#888"></span>};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
  vector&lt;<span style="color:#888;font-weight:bold">int</span>&gt; vec_int;		<span style="color:#888">// default init
</span><span style="color:#888"></span>  vector&lt;<span style="color:#888;font-weight:bold">double</span>&gt; vec_double;
  vector&lt;vector&lt;<span style="color:#888;font-weight:bold">double</span>&gt;&gt; vec_of_vec_double; <span style="color:#888">// each element is a vector of double
</span><span style="color:#888"></span>}</code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-123" class="outline-3">
<h3 id="headline-123">
Type as template parameters
</h3>
<div id="outline-text-headline-123" class="outline-text-3">
<p>Goal is to make the element type a parameter to a vector class.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Vector</span> {
<span style="color:#888;font-weight:bold">int</span> size;
<span style="color:#888;font-weight:bold">int</span> space;
<span style="color:#080;font-weight:bold">public</span>:
Vector(): size{<span style="color:#00d;font-weight:bold">0</span>}, space{<span style="color:#00d;font-weight:bold">0</span>} {};		<span style="color:#888">// constructor
</span><span style="color:#888"></span>};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
Vector myvec;			<span style="color:#888">// instantiate class
</span><span style="color:#888"></span>
}</code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-124" class="outline-3">
<h3 id="headline-124">
Passing function or functor as arguments
</h3>
<div id="outline-text-headline-124" class="outline-text-3">
<p>
A templated function allows the compiler to know if <code class="verbatim">func</code> is a function or a functor.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">template</span> &lt;<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">T</span>&gt; <span style="color:#888;font-weight:bold">double</span> Quadrature(T &amp;func, <span style="color:#888;font-weight:bold">double</span> a) { <span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">func</span>(a); };

<span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">f</span>(<span style="color:#888;font-weight:bold">double</span> x) { <span style="color:#080;font-weight:bold">return</span> x * x; }; <span style="color:#888">// defining a function
</span><span style="color:#888"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() { std::cout &lt;&lt; Quadrature(f, <span style="color:#00d;font-weight:bold">2</span>); } <span style="color:#888">// passing a function as argument
</span></code></pre></div>
</div>
<pre class="example">
4
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-125" class="outline-2">
<h2 id="headline-125">
Numerics
</h2>
<div id="outline-text-headline-125" class="outline-text-2">
<div id="outline-container-headline-126" class="outline-3">
<h3 id="headline-126">
Accumulate
</h3>
<div id="outline-text-headline-126" class="outline-text-3">
<p>As an introduction to the numerical library.</p>
<p>
The function takes</p>
<ol>
<li>
<p>first element of the sequence</p>
</li>
<li>
<p>last element of the sequence</p>
</li>
<li>
<p>initial value (accumulator variable)</p>
</li>
</ol>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;numeric&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span> () {
<span style="color:#888;font-weight:bold">int</span> a[] = {<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">2</span>, <span style="color:#00d;font-weight:bold">3</span>, <span style="color:#00d;font-weight:bold">4</span>};
std::cout &lt;&lt; <span style="color:#080;font-weight:bold">sizeof</span>(a) &lt;&lt; std::endl;
std::cout &lt;&lt; <span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#888;font-weight:bold">int</span>) &lt;&lt; std::endl;
std::cout &lt;&lt; std::accumulate(a, a+<span style="color:#080;font-weight:bold">sizeof</span>(a)/<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#888;font-weight:bold">int</span>), <span style="color:#00d;font-weight:bold">0</span>);
}</code></pre></div>
</div>
<pre class="example">
16
4
12
</pre>
<p>
Remarks:</p>
<ol>
<li>
<p>the end of the sequence was defined with the size function of the whole sequence (16) which represents 4 integers (4);</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-127" class="outline-2">
<h2 id="headline-127">
Libraries
</h2>
<div id="outline-text-headline-127" class="outline-text-2">
<div id="outline-container-headline-128" class="outline-3">
<h3 id="headline-128">
Standard library
</h3>
<div id="outline-text-headline-128" class="outline-text-3">
<p>Libraries that provide some useful tools (data structures and algorithms) for every programmer.</p>
</div>
</div>
<div id="outline-container-headline-129" class="outline-3">
<h3 id="headline-129">
Headers and namespace
</h3>
<div id="outline-text-headline-129" class="outline-text-3">
<p>A header argument provides a standard library facility.
Standard library is defined in a namespace <code class="verbatim">std</code>, which is a prefix that access the facilities.
The prefix can be avoided with <code class="verbatim">using namespace std;</code>.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span><span style="color:#c00;font-weight:bold">&lt;string&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() { std::string s{<span style="color:#d20;background-color:#fff0f0">&#34;a string&#34;</span>}; }</code></pre></div>
</div>
<div id="outline-container-headline-130" class="outline-3">
<h3 id="headline-130">
External libraries
</h3>
<div id="outline-text-headline-130" class="outline-text-3">
<p>
With an external library source code in a specific folder.</p>
<p>
We need:</p>
<ol>
<li>
<p>compile our code including the path of the library that we downloaded</p>
<ol>
<li>
<p>compiler must know where the library header files are (<code class="verbatim">.h</code>)</p>
</li>
</ol>
</li>
<li>
<p>linker must know where the libraries are (for static or dynamic linking)</p>
<ol>
<li>
<p>linker must know where the &#34;implementation&#34; of the things &#34;declared&#34; in the header files</p>
</li>
<li>
<p>libsynaptics</p>
</li>
<li>
</li>
</ol>
</li>
</ol>
<div id="outline-container-headline-131" class="outline-5">
<h5 id="headline-131">
General definitions
</h5>
<div id="outline-text-headline-131" class="outline-text-5">
<p>A library is just code with <span style="text-decoration: underline;">declarations</span> with statements of how to use the functions and classes.</p>
<ol>
<li>
<p>static libraries are represented with <code class="verbatim">.lib</code> or <code class="verbatim">.a</code></p>
</li>
<li>
<p>dynamic libraries with <code class="verbatim">.dll</code> or <code class="verbatim">.so</code></p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-132" class="outline-5">
<h5 id="headline-132">
Including a library in <code class="verbatim">/usr/include/</code>
</h5>
<div id="outline-text-headline-132" class="outline-text-5">
<p>C++ compiler founds automatically external libraries in the folder <code class="verbatim">/usr/include/</code>.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;library_name/headerfile.h&gt;</span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-133" class="outline-5">
<h5 id="headline-133">
Including a library elsewhere
</h5>
<div id="outline-text-headline-133" class="outline-text-5">
<p>
Need to find the path to the library header file.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-134" class="outline-3">
<h3 id="headline-134">
Static and dynamic libraries
</h3>
<div id="outline-text-headline-134" class="outline-text-3">
<p>
Static libraries (also known as &#34;archive&#34;) are linked to the programs at <span style="text-decoration: underline;">compile time</span>.
The executable has a copy of library code, makes it bloated.
If we modify the library we need to recompile and link again the other parts of the application that depend on this library.</p>
<p>
On the other hand, dynamic or shared libraries have code that is meant to be used by multiple programs.
The content is loaded to the memory at <span style="text-decoration: underline;">runtime</span> and only once.
Loading a library dynamic is more efficient way to use memory when there are more than one executable running and depending on the dynamic library content.
One hurdle is a more intricate installation process regarding proper placement of the library.</p>
<p>
Reference: <a href="https://domiyanyue.medium.com/c-development-tutorial-4-static-and-dynamic-libraries-7b537656163e">C++ Development Tutorial 4: Static and Dynamic Libraries | by Domi Yan | Medium</a></p>
</div>
</div>
<div id="outline-container-headline-135" class="outline-3">
<h3 id="headline-135">
Using dynamic libraries
</h3>
<div id="outline-text-headline-135" class="outline-text-3">
<p>
Dynamic libraries can be used by compiling your program together with the shared library file.</p>
<p>
Let&#39;s say we have this header file called <code class="verbatim">mymath.h</code> with a declaration of a function</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">reciprocal</span> (<span style="color:#888;font-weight:bold">double</span> x);</code></pre></div>
</div>
<p>
and its implementation/definition in <code class="verbatim">mymath.cpp</code></p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&#34;mymath.h&#34;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">reciprocal</span> (<span style="color:#888;font-weight:bold">double</span> x) { <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1.</span> / x; }</code></pre></div>
</div>
<p>
We want to use this &#34;library&#34; in our program.
We just want to use the function <code class="verbatim">reciprocal</code> without having to worry about compilations details of this library.
Then, we build the shared library with</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">clang++ -shared -o libmath.so mymath.cpp
ls</code></pre></div>
</div>
<table>
<tbody>
<tr>
<td>libmath.so</td>
</tr>
<tr>
<td>main.cpp</td>
</tr>
<tr>
<td>mymath.cpp</td>
</tr>
<tr>
<td>mymath.h</td>
</tr>
</tbody>
</table>
<p>
Now we have the library we want to use compiled as a shared library <code class="verbatim">libmath.so</code>.
In our code we then include the declaration of the function with the head <code class="verbatim">math.h</code>, and use the function.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&#34;mymath.h&#34;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
std::cout &lt;&lt; reciprocal(<span style="color:#00d;font-weight:bold">2.</span>); 
}</code></pre></div>
</div>
<p>
When we compile our code, we use the commands bellow.
Notice that we manually have to pass the library path to the linker with <code class="verbatim">-rpath</code> flag.
The flag <code class="verbatim">-Wl</code> is used to pass a list of arguments to the linker.</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">clang++ main.cpp libmath.so -Wl,-rpath,/mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes
./a.out</code></pre></div>
</div>
<pre class="example">
0.5
</pre>
<p>
It seems that CMake builds the executable with the RPATH for the build tree (<a href="https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling).">https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling).</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-136" class="outline-2">
<h2 id="headline-136">
Effective and modern
</h2>
<div id="outline-text-headline-136" class="outline-text-2">
<div id="outline-container-headline-137" class="outline-3">
<h3 id="headline-137">
Template type deduction
</h3>
<div id="outline-text-headline-137" class="outline-text-3">
<p>Frees you from typing obvious or redundant types.</p>
<p>
Appears in calls to function templates and when auto is used. </p>
</div>
</div>
<div id="outline-container-headline-138" class="outline-3">
<h3 id="headline-138">
<span class="todo">TODO</span>
<code class="verbatim">auto</code> type deduction (2 Meyers)
</h3>
<div id="outline-text-headline-138" class="outline-text-3">
<div id="outline-container-headline-139" class="outline-4">
<h4 id="headline-139">
Why prefer <code class="verbatim">auto</code> to explicit type declarations?
</h4>
</div>
</div>
</div>
<div id="outline-container-headline-140" class="outline-3">
<h3 id="headline-140">
Smart pointers
</h3>
<div id="outline-text-headline-140" class="outline-text-3">
<div id="outline-container-headline-141" class="outline-4">
<h4 id="headline-141">
What is it smart about it?
</h4>
</div>
</div>
</div>
<div id="outline-container-headline-142" class="outline-3">
<h3 id="headline-142">
Universal references (&amp;&amp;)
</h3>
<div id="outline-text-headline-142" class="outline-text-3">
<div id="outline-container-headline-143" class="outline-4">
<h4 id="headline-143">
What is an universal reference?
</h4>
<div id="outline-text-headline-143" class="outline-text-4">
<p>It is a term to describe the concept of: taking an <code class="verbatim">rvalue</code> reference to a cv-unqualified template, which can be deduced as a <code class="verbatim">rvalue</code> or <code class="verbatim">lvalue</code>.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Widget</span> {
<span style="color:#080;font-weight:bold">public</span>:
Widget(Widget&amp;&amp; rhs);		<span style="color:#888">// an argument to this constructor will bind to an rvalue reference
</span><span style="color:#888"></span>};

<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
<span style="color:#888;font-weight:bold">int</span> a = <span style="color:#00d;font-weight:bold">1</span>;			<span style="color:#888">// a is an lvalue 
</span><span style="color:#888"></span>Widget myobject(a);
}</code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-144" class="outline-3">
<h3 id="headline-144">
Modern practices
</h3>
<div id="outline-text-headline-144" class="outline-text-3">
<div id="outline-container-headline-145" class="outline-4">
<h4 id="headline-145">
<span class="todo">TODO</span>
Why choose <code class="verbatim">()</code> instead <code class="verbatim">{}</code> when creating objects matter? (7 Mayers)
</h4>
<div id="outline-text-headline-145" class="outline-text-4">
<div id="outline-container-headline-146" class="outline-5">
<h5 id="headline-146">
Possible initialization operators
</h5>
<div id="outline-text-headline-146" class="outline-text-5">
<p>Object initilization:</p>
<ol>
<li>
<p><code class="verbatim">int x(0);</code> with parenthesis</p>
</li>
<li>
<p><code class="verbatim">int x=0;</code> with equal sign</p>
</li>
<li>
<p><code class="verbatim">int x{0};</code> with braces</p>
</li>
<li>
<p><code class="verbatim">int x = {0};</code> with equal sign and braces</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-147" class="outline-5">
<h5 id="headline-147">
Problems with <code class="verbatim">= {};</code> 
</h5>
<div id="outline-text-headline-147" class="outline-text-5">
<ol>
<li>
<p>Usage of equal sign is confused with object <em>assignment</em> (calls to <code class="verbatim">copy operator=</code>).</p>
</li>
</ol>
<p>Braced initialization is an <em>uniform initialization</em> that can be used anywhere.
There are situations where initilization with <code class="verbatim">()</code> and <code class="verbatim">=</code> does not work, for instance default value of private class members and uncopyable objects respectively.</p>
</div>
</div>
<div id="outline-container-headline-148" class="outline-5">
<h5 id="headline-148">
Narrowing conversion
</h5>
<div id="outline-text-headline-148" class="outline-text-5">
<p>Braced <code class="verbatim">{}</code> initialization prohibits <span style="text-decoration: underline;">implicit narrowing conversions</span> among built-in types.
If the type of the expression in the brace in not guaranteed to be expressible by the <em>type of the object been initialized</em>, it gives an error.</p>
<p>
Initilization with  <code class="verbatim">=</code> Meyers says it works.</p>
<p>
From this experience with <em>clang</em> compiler, it seems that both can be done and the double is converted to int automatically.
The compiler just gives a warning: <code class="verbatim">clang: Type &#39;double&#39; cannot be narrowed to &#39;int&#39; in initializer list (fix available)</code>.</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
<span style="color:#888;font-weight:bold">int</span> x {<span style="color:#00d;font-weight:bold">2</span>};		
<span style="color:#888;font-weight:bold">double</span> y {<span style="color:#00d;font-weight:bold">1.99</span>};
<span style="color:#888;font-weight:bold">int</span> sum{x + y}; <span style="color:#888">// clang: Type &#39;double&#39; cannot be narrowed to &#39;int&#39; in
</span><span style="color:#888">// initializer list (fix available)
</span><span style="color:#888"></span>std::cout &lt;&lt; sum;
<span style="color:#888;font-weight:bold">int</span> sum2 = x + y;		<span style="color:#888">// clang also gives an  
</span><span style="color:#888"></span>}</code></pre></div>
</div>
<pre class="example">
3
</pre>
</div>
</div>
<div id="outline-container-headline-149" class="outline-5">
<h5 id="headline-149">
Problems with <code class="verbatim">{}</code> braced initialization
</h5>
<div id="outline-text-headline-149" class="outline-text-5">
<p>
If the class has a constructor, <em>ctor</em>, that has an <code class="verbatim">std::initilize_list</code> as argument it seems that the compiler &#34;strongly prefer&#34; overloads taking this list initialization constructor.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-150" class="outline-4">
<h4 id="headline-150">
What are scoped <code class="verbatim">enums</code>?
</h4>
</div>
<div id="outline-container-headline-151" class="outline-4">
<h4 id="headline-151">
What are special function generation?
</h4>
</div>
<div id="outline-container-headline-152" class="outline-4">
<h4 id="headline-152">
Pass by value or pass by reference?
</h4>
</div>
</div>
</div>
<div id="outline-container-headline-153" class="outline-3">
<h3 id="headline-153">
Abstract base class (ABC) or Template
</h3>
<div id="outline-text-headline-153" class="outline-text-3">
<p>When a function is intended to process on multiple object types.
We can have an abstract class and multiple derived ones or a function with a template.</p>
<p>
The template must be available to the compiler every time it encounter a call to the function.
The compiler in fact needs to compile a different version of the templated function each time it encounter a different type.</p>
<p>
In the case of the template solution, the consistency will be enforced when the templated function is actually called with an specific argument type.
Not when the object type is defined.
This can be hard to debug in some cases.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-154" class="outline-2">
<h2 id="headline-154">
Compiler
</h2>
<div id="outline-text-headline-154" class="outline-text-2">
<div id="outline-container-headline-155" class="outline-4">
<h4 id="headline-155">
Compilation
</h4>
<div id="outline-text-headline-155" class="outline-text-4">
<p>
The <span style="text-decoration: underline;">compiler</span> translates the source code from human language to machine language (executable or object code).</p>
</div>
</div>
<div id="outline-container-headline-156" class="outline-4">
<h4 id="headline-156">
Linking
</h4>
<div id="outline-text-headline-156" class="outline-text-4">
<p>All parts of the program must be compile and the resulted <span style="text-decoration: underline;">object code files <code class="verbatim">.obj</code> must be linked</span> to form an executable program.
The linker is responsible for linking.</p>
<p>
Object code and executable <strong>are not portable</strong> among different systems.</p>
</div>
</div>
<div id="outline-container-headline-157" class="outline-4">
<h4 id="headline-157">
Makefile
</h4>
<div id="outline-text-headline-157" class="outline-text-4">
<p>
It is a file that manages the compiling of a project (multiple c++ files). 
When you call <code class="verbatim">make</code> it uses the <code class="verbatim">Makefile</code> instructions.</p>
<p>
The management means:</p>
<ol>
<li>
<p>specify &#34;targets&#34; and list of dependencies</p>
<ol>
<li>
<p>a target can be a word (a phony) such as &#34;all&#34;and &#34;clear&#34; or a file name</p>
</li>
<li>
<p>convention is to use the first target &#34;all&#34; will run with simple <code class="verbatim">make</code></p>
</li>
</ol>
</li>
<li>
<p>specify &#34;make actions&#34;, e.g. clean or build</p>
</li>
<li>
<p>specify files/objects that make need to build</p>
</li>
</ol>
<p>A sample Makefile would look like</p>
<pre class="example">
all: mybinary

mybinary: files.o
commands

files.o: files.cpp files.h
commands
</pre>
</div>
</div>
<div id="outline-container-headline-158" class="outline-4">
<h4 id="headline-158">
Configure
</h4>
<div id="outline-text-headline-158" class="outline-text-4">
<p>This script is used to set up the building process.
The set up involves making sure that all tools necessary are available in the <span style="text-decoration: underline;">specific environment</span> where the program is going to be built.
For instance, which compiler is it going to use to translate the source code?</p>
<p>
When we call <code class="verbatim">./configure</code> it produces <code class="verbatim">Makefiles</code> specific for the current system (usually from a template <code class="verbatim">Makefile.in</code>).</p>
<p>
The <code class="verbatim">./configure</code> script examines the system and get appropriate paths.
Usually the <code class="verbatim">./configure</code> and <code class="verbatim">Makefile.in</code> template are automatically generated with other tools.</p>
</div>
</div>
<div id="outline-container-headline-159" class="outline-4">
<h4 id="headline-159">
Make
</h4>
<div id="outline-text-headline-159" class="outline-text-4">
<p>
The command <code class="verbatim">make</code> is responsible to &#34;<span style="text-decoration: underline;">build</span>&#34; the software.
It takes the <code class="verbatim">./Makefile</code> and build the first target.
The <code class="verbatim">Makefile</code> has <span style="text-decoration: underline;">instructions to compile</span> all the files that we need for our program.</p>
</div>
</div>
<div id="outline-container-headline-160" class="outline-4">
<h4 id="headline-160">
Subsequent <code class="verbatim">Make</code> calls
</h4>
<div id="outline-text-headline-160" class="outline-text-4">
<p>
When we run <code class="verbatim">make</code> it will check if the file with target: &#34;all&#34; is updated.
If it is not newer than its dependencies, it will call the command to <span style="text-decoration: underline;">rebuild</span> the binary.</p>
</div>
</div>
<div id="outline-container-headline-161" class="outline-4">
<h4 id="headline-161">
Make usage
</h4>
<div id="outline-text-headline-161" class="outline-text-4">
<p>If we want to compile <code class="verbatim">main.cpp</code> (from the example in <a href="*Using dynamic libraries">Using dynamic libraries</a>) for instance, the <code class="verbatim">Makefile</code> should have</p>
<pre class="example">
default:
clang++ main.cpp mymath.cpp -o output_with_make.out
</pre>
<p>
Then, we can run with</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">make
./output_with_make.out</code></pre></div>
</div>
<pre class="example">
clang++ main.cpp mymath.cpp -o output_with_make.out
0.5
</pre>
<p>
References: <a href="https://makefiletutorial.com/">Makefile Tutorial By Example</a></p>
</div>
</div>
<div id="outline-container-headline-162" class="outline-4">
<h4 id="headline-162">
Make install
</h4>
<div id="outline-text-headline-162" class="outline-text-4">
<p>
The command <code class="verbatim">make install</code> copies the binaries from the step (with <code class="verbatim">make</code>) and put them into appropriate locations to be accessed.</p>
<p>
The locations are defined in the <code class="verbatim">Makefile</code>.
In the <code class="verbatim">./condigure</code> step we can pass specific value so the appropriate locations are set in the <code class="verbatim">Makefile</code>.</p>
<p>
If the location requires administrative privileges we can use <code class="verbatim">sudo make install</code> to accomplish the copying task.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-163" class="outline-2">
<h2 id="headline-163">
CMake
</h2>
<div id="outline-text-headline-163" class="outline-text-2">
<div id="outline-container-headline-164" class="outline-4">
<h4 id="headline-164">
Introduction
</h4>
<div id="outline-text-headline-164" class="outline-text-4">
<p>CMake is a system that manages the build process (configures the project) of a executable or library.
The build process consist of configuring and generating project files, the <em>setup stage</em>.
These project files work together with a native build tools (make for Linux, visual studio).
It substitute the manual creation of Makefiles.</p>
<p>
CMake uses <code class="verbatim">CMakeLists.txt</code> file in the source directory with configuration to generate &#34;standard build files&#34;, e.g. makefiles on Linux and projects/workspaces on Windows.</p>
<p>
CMake can create <em>native build environment</em> (?) to compile the source code, <em>create libraries</em> (?), 
A build environment is what a specific system uses to create executables from source code and libraries as well.
In Linux, the command <code class="verbatim">make</code> is responsible for that, whereas in windows, visual studio handles the build process.</p>
<p>
A typical <code class="verbatim">CMakeLists.txt</code> would contain:</p>
<pre class="example">
cmake_minimum_required(version x.x)

project(project_name)

add_executable(project_name main.cpp)
</pre>
<p>
Reference: <a href="https://tuannguyen68.gitbooks.io/learning-cmake-a-beginner-s-guide/content/chap1/chap1.html">Tutorial 1: Let&amp;apos;s start with CMake | Learning CMake: A beginner&amp;apos;s g…</a></p>
</div>
</div>
<div id="outline-container-headline-165" class="outline-4">
<h4 id="headline-165">
Project setup
</h4>
<div id="outline-text-headline-165" class="outline-text-4">
<p>
A build system transforms a collection of files into a coherent project.
CMake uses <code class="verbatim">CMakeLists.txt</code> to define what should be built, how is built, what tests to run and what packages to create.
It contain a <em>description</em> of the project.</p>
<p>
A project has a source directory, <code class="verbatim">src</code>, and a binary directory <code class="verbatim">bin</code> (aka build directory).
The binary directory is the destination of everything the build system creates, e.g. executables, libraries, test output and packages.</p>
</div>
</div>
<div id="outline-container-headline-166" class="outline-4">
<h4 id="headline-166">
File generator
</h4>
<div id="outline-text-headline-166" class="outline-text-4">
<p>
Makefiles, visual studio and ninja.
CMake produce <em>project files</em> that are adequate to a particular file generator depending o the system.</p>
<p>
The project files creating involves 1) configuring and 2) generating.</p>
</div>
</div>
<div id="outline-container-headline-167" class="outline-4">
<h4 id="headline-167">
Using CMake
</h4>
<div id="outline-text-headline-167" class="outline-text-4">
<div id="outline-container-headline-168" class="outline-6">
<h6 id="headline-168">
Basic setup
</h6>
<div id="outline-text-headline-168" class="outline-text-6">
<p>If we want to build our <code class="verbatim">main.cpp</code> with the content:</p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&lt;iostream&gt;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&#34;mymath.h&#34;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
std::cout &lt;&lt; reciprocal(<span style="color:#00d;font-weight:bold">2.</span>); 
}</code></pre></div>
</div>
<p>
where the header <code class="verbatim">mymath.h</code> has the declaration of the function <code class="verbatim">reciprocal</code> and the file <code class="verbatim">mymath.cpp</code> has its implementation </p>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">reciprocal</span> (<span style="color:#888;font-weight:bold">double</span> x);</code></pre></div>
</div>
<div class="src src-c++">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#c00;font-weight:bold">#include</span> <span style="color:#c00;font-weight:bold">&#34;mymath.h&#34;</span><span style="color:#c00;font-weight:bold">
</span><span style="color:#c00;font-weight:bold"></span>
<span style="color:#888;font-weight:bold">double</span> <span style="color:#06b;font-weight:bold">reciprocal</span> (<span style="color:#888;font-weight:bold">double</span> x) { <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1.</span> / x; }</code></pre></div>
</div>
<p>
The files are:</p>
<table>
<tbody>
<tr>
<td>main.cpp</td>
</tr>
<tr>
<td>mymath.cpp</td>
</tr>
<tr>
<td>mymath.h</td>
</tr>
</tbody>
</table>
<p>
Then, we create an empty <code class="verbatim">CMakeLists.txt</code> file on the source code.</p>
<pre class="example">
CMakeLists.txt
main.cpp
mymath.cpp
mymath.h
</pre>
<p>
Then, to get out our configured build system from CMake we create a separate <code class="verbatim">/build/</code> folder and run <code class="verbatim">cmake</code> on our source code:</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mkdir build			<span style="color:#888"># create build directory</span>
<span style="color:#038">cd</span> build			<span style="color:#888"># go to the build directory</span>
cmake -S ../ -B .		<span style="color:#888"># Source and Build directories</span>
ls</code></pre></div>
</div>
<pre class="example">
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes/build
CMakeCache.txt
CMakeFiles
Makefile
cmake_install.cmake
</pre>
<p>
Inside the build directory a <code class="verbatim">Makefile</code> was created by CMake with the content,</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#038">cd</span> build
head --lines=<span style="color:#00d;font-weight:bold">20</span> Makefile	<span style="color:#888"># limit to only the first 20 lines</span></code></pre></div>
</div>
<pre class="example">
# CMAKE generated file: DO NOT EDIT!
# Generated by &#34;Unix Makefiles&#34; Generator, CMake Version 3.20

# Default target executed when no arguments are given to make.
default_target: all
.PHONY : default_target

# Allow only one &#34;make -f Makefile2&#34; at a time, but pass parallelism.
.NOTPARALLEL:

#=============================================================================
# Special targets provided by cmake.

# Disable implicit rules so canonical targets will work.
.SUFFIXES:

# Disable VCS-based implicit rules.
% : %,v

# Disable VCS-based implicit rules.
</pre>
<p>
This <code class="verbatim">Makefile</code> created by CMake has a bunch of predefined defaults even with the <code class="verbatim">CMakeLists.txt</code> empty.
If we try to <code class="verbatim">build</code> our project with this <code class="verbatim">Makefile</code>, we get nothing because there was no mention of our code in it.
However there are no errors in the process.</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#038">cd</span> build
make
ls</code></pre></div>
</div>
<pre class="example">
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes/build
CMakeCache.txt
CMakeFiles
Makefile
cmake_install.cmake
</pre>
<p>
Reference: <a href="https://cmake.org/cmake/help/git-stage/guide/tutorial/index.html">CMake Tutorial — CMake 3.20.20210421-g8d4c864 Documentation</a></p>
</div>
</div>
<div id="outline-container-headline-169" class="outline-6">
<h6 id="headline-169">
Adding information to <code class="verbatim">CMakeLists.txt</code>
</h6>
<div id="outline-text-headline-169" class="outline-text-6">
<p>
Now, if we have a <code class="verbatim">CMakeLists.txt</code> with just a reference to our main file</p>
<pre class="example">
cmake_minimum_required(VERSION 3.17)

project(myproject)

add_executable(project_name main.cpp)
</pre>
<p>
and run <code class="verbatim">cmake</code> to configure our project</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mkdir build2
<span style="color:#038">cd</span> build2
cmake -S ../ -B .</code></pre></div>
</div>
<pre class="example">
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes/build2
</pre>
<p>
now, if we build with <code class="verbatim">make</code> </p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#038">cd</span> build2
make</code></pre></div>
</div>
<p>
<code class="verbatim">main.cpp:(.text+0x15): undefined reference to `reciprocal(double)&#39;</code></p>
<p>
we get an error saying that a reference is undefined.</p>
</div>
</div>
<div id="outline-container-headline-170" class="outline-6">
<h6 id="headline-170">
Adding multiple sources to <code class="verbatim">CMakeLists.txt</code>
</h6>
<div id="outline-text-headline-170" class="outline-text-6">
<p>Adding a reference to the file with the function definition.</p>
<pre class="example">
cmake_minimum_required(VERSION 3.17)

project(myproject)

add_executable(project_name main.cpp mymath.cpp)
</pre>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mkdir build3
<span style="color:#038">cd</span> build3
cmake -S ../ -B .
make</code></pre></div>
</div>
<pre class="example">
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes/build3
[ 33%] Building CXX object CMakeFiles/project_name.dir/main.cpp.o
[ 66%] Building CXX object CMakeFiles/project_name.dir/mymath.cpp.o
[100%] Linking CXX executable project_name
[100%] Built target project_name
</pre>
<p>
and we can run the code by calling the executable</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#038">cd</span> build3
./project_name</code></pre></div>
</div>
<pre class="example">
0.5
</pre>
</div>
</div>
<div id="outline-container-headline-171" class="outline-6">
<h6 id="headline-171">
Adding a dynamic library to <code class="verbatim">CMakeLists.txt</code>
</h6>
<div id="outline-text-headline-171" class="outline-text-6">
<p>
Now we want to compile our project using a ready to use dynamic library created by someone else.
For the example lets compile our dynamic/shared library with the function definition.</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">clang++ -shared -o libmymath.so mymath.cpp
ls</code></pre></div>
</div>
<p>
The resulting folder structure is</p>
<pre class="example">
CMakeLists.txt
libmymath.so
main.cpp
mymath.cpp
mymath.h
</pre>
<p>
Now, with our dynamic library <code class="verbatim">libmymath.so</code> ready, let&#39;s include it on our project.</p>
<p>
In order to <em>import</em> a library into another project we use the concept of importing targets <a href="https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/Exporting-and-Importing-Targets">Exporting and Importing Targets · Wiki · CMake / Community · GitLab</a>.
The command <code class="verbatim">add_library</code> when importing from an outside library must have the <code class="verbatim">IMPORTED</code> option together with the library type <code class="verbatim">SHARED</code> or <code class="verbatim">STATIC</code>.
Then we need to tell CMake where this library is located with the <code class="verbatim">set_property</code> command.</p>
<pre class="example">
cmake_minimum_required(VERSION 3.17)

project(myproject)

add_library(libmymath SHARED IMPORTED)
set_property(TARGET libmymath PROPERTY IMPORTED_LOCATION ../libmymath.so)

add_executable(project_name main.cpp)

target_link_libraries(myproject libmymath)
</pre>
<p>
When we run <code class="verbatim">cmake</code> with that, it will add a rule to link the library to the project executable.</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mkdir build4
<span style="color:#038">cd</span> build4
cmake -S ../ -B .
make</code></pre></div>
</div>
<pre class="example">
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes/build4
[ 50%] Building CXX object CMakeFiles/myproject.dir/main.cpp.o
[100%] Linking CXX executable myproject
[100%] Built target myproject
</pre>
<p>
Then running the generated executable</p>
<div class="src src-shell">
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#038">cd</span> build4
./myproject</code></pre></div>
</div>
<pre class="example">
0.5
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-172" class="outline-2">
<h2 id="headline-172">
References
</h2>
<div id="outline-text-headline-172" class="outline-text-2">
<ul>
<li>
<p>Stroustrup, B. (2014). Programming: principles and practice using C++. Upper Saddle River, NJ: Addison-Wesley.</p>
</li>
<li>
<p>Stroustrup, B., &amp; Stroustrup, B. (2014). A tour of C++. Upper Saddle River, NJ: Addison-Wesley.</p>
</li>
<li>
<p>Scott, C. (). Professional CMake. : .</p>
</li>
</ul>
</div>
</div>


              
                  

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>
              
          </article>
          

<ul class="tags__list">
    
    <li class="tag__item">
        <a class="tag__link" href="https://nasseralkmim.github.io/tags/c&#43;&#43;/">c&#43;&#43;</a>
    </li></ul>

 <div class="pagination">
  
    <a class="pagination__item" href="https://nasseralkmim.github.io/notes/cpp-environment-setup/">
        <span class="pagination__label">Previous Post</span>
        <span class="pagination__title">C&#43;&#43; Development environment in Emacs</span>
    </a>
  

  
    <a class="pagination__item" href="https://nasseralkmim.github.io/notes/jacobi-method/">
      <span class="pagination__label">Next Post</span>
      <span class="pagination__title" >Jacobi method</span>
    </a>
  
</div>

          <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "nasseralkmim" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          <footer class="post__footer">
            


<div class="social-icons">
  
     
    
      <a class="social-icons__link" rel="me" title="Email"
         href="mailto:nasser.alkmim@gmail.com"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://nasseralkmim.github.io/svg/email.svg')"></div>
      </a>
    
  
     
    
      <a class="social-icons__link" rel="me" title="LinkedIn"
         href="https://www.linkedin.com/in/nasser-alkmim-300882a6/"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://nasseralkmim.github.io/svg/linkedin.svg')"></div>
      </a>
    
  
     
    
      <a class="social-icons__link" rel="me" title="GitHub"
         href="https://github.com/nasseralkmim"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://nasseralkmim.github.io/svg/github.svg')"></div>
      </a>
    
  
     
    
      <a class="social-icons__link" rel="me" title="Instagram"
         href="https://instagram.com/naszr"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://nasseralkmim.github.io/svg/instagram.svg')"></div>
      </a>
    
     
</div>

            <p>© 2021</p>
          </footer>
          </div>
      </div>
      
      <div class="toc-container">
           <div class="toc-post-title">C&#43;&#43; Notes</div> 
        <nav id="TableOfContents">
<ul>
<li><a href="#headline-1">Introduction</a>
</li>
<li><a href="#headline-2">Advice</a>
<ul>
<li><a href="#headline-3">General</a>
</li>
<li><a href="#headline-4">Programming practices</a>
</li>
<li><a href="#headline-5">Naming conventions</a>
</li>
</ul>
</li>
<li><a href="#headline-6">Technicalities</a>
<ul>
<li><a href="#headline-7">Declarations and definitions</a>
</li>
<li><a href="#headline-8">Headers</a>
</li>
<li><a href="#headline-9">Namespace</a>
</li>
<li><a href="#headline-10">Operators</a>
<ul>
<li><a href="#headline-11">Logical operators (!, &amp;&amp;, ||)</a>
</li>
<li><a href="#headline-12">Compound assignments (+=, *=)</a>
</li>
<li><a href="#headline-13">Member access operators (., -&gt;)</a>
</li>
<li><a href="#headline-14">Conditional ternary (?)</a>
</li>
<li><a href="#headline-15">Scope resolution (::)</a>
</li>
<li><a href="#headline-16">Math operators</a>
</li>
</ul>
</li>
<li><a href="#headline-17">Bitwise left and right shift (&lt;&lt;, &gt;&gt;)</a>
</li>
<li><a href="#headline-18">Semicolon</a>
</li>
<li><a href="#headline-19">Move semantics</a>
<ul>
<li><a href="#headline-20">What is the difference <code class="verbatim">rvalues</code> and <code class="verbatim">lvalues</code>?</a>
</li>
<li><a href="#headline-21">What is the difference between <em>move operator</em> and <em>copy operator</em>?</a>
</li>
</ul>
</li>
<li><a href="#headline-22">Type safety</a>
</li>
<li><a href="#headline-23">Overloading</a>
</li>
<li><a href="#headline-24"><code class="verbatim">const</code> correctness</a>
</li>
<li><a href="#headline-25">Passing parameter by value</a>
</li>
</ul>
</li>
<li><a href="#headline-26">Basics</a>
<ul>
<li><a href="#headline-27">Minimal program</a>
</li>
<li><a href="#headline-28">Hello world</a>
</li>
<li><a href="#headline-29">Functions</a>
</li>
<li><a href="#headline-30">Scope</a>
</li>
<li><a href="#headline-31">Pointers</a>
</li>
<li><a href="#headline-32"><code class="verbatim">new</code> operator</a>
</li>
<li><a href="#headline-33"><code class="verbatim">const</code> operator</a>
<ul>
<li><a href="#headline-34"><code class="verbatim">const</code> variable</a>
</li>
<li><a href="#headline-35"><code class="verbatim">const</code> pointer</a>
</li>
<li><a href="#headline-36"><code class="verbatim">const</code> function argument</a>
</li>
<li><a href="#headline-37"><code class="verbatim">const</code> after the arguments of a member function</a>
</li>
</ul>
</li>
<li><a href="#headline-38">Declarator operators</a>
</li>
<li><a href="#headline-39">Range-for-statement</a>
</li>
<li><a href="#headline-40">Tests</a>
</li>
<li><a href="#headline-41">Variable initialization</a>
</li>
<li><a href="#headline-42"><code class="verbatim">cout</code> versus <code class="verbatim">printf</code></a>
</li>
<li><a href="#headline-43">How many bytes?</a>
</li>
</ul>
</li>
<li><a href="#headline-44">Pointers</a>
<ul>
<li><a href="#headline-45">Memory</a>
</li>
<li><a href="#headline-46">Pointer definition</a>
</li>
<li><a href="#headline-47">Pointer type</a>
</li>
<li><a href="#headline-48">&#34;Address of&#34; operator (&amp;)</a>
</li>
<li><a href="#headline-49">&#34;Contents of&#34; operator (*)</a>
</li>
<li><a href="#headline-50">Access object pointed to by a pointer</a>
</li>
<li><a href="#headline-51">Null pointer</a>
</li>
<li><a href="#headline-52">References</a>
</li>
<li><a href="#headline-53">When to use references</a>
</li>
<li><a href="#headline-54">Pointer and reference parameters</a>
</li>
<li><a href="#headline-55">Protecting data &#34;pointed to&#34; when passing by reference</a>
</li>
</ul>
</li>
<li><a href="#headline-56">Classes</a>
<ul>
<li><a href="#headline-57">Definitionss</a>
<ul>
<li><a href="#headline-58">Class and objects</a>
</li>
<li><a href="#headline-59">Types</a>
</li>
<li><a href="#headline-60">User defined type (UDT)</a>
</li>
<li><a href="#headline-61">Built in types (BIT)</a>
</li>
<li><a href="#headline-62">Standard librar types (SLT)</a>
</li>
<li><a href="#headline-63">Defining and instantiating an object</a>
</li>
<li><a href="#headline-64">Uses of classes</a>
</li>
<li><a href="#headline-65">Containers</a>
</li>
</ul>
</li>
<li><a href="#headline-66">Classes and members</a>
</li>
<li><a href="#headline-67">Interface and implementation</a>
</li>
<li><a href="#headline-68">Structures</a>
</li>
<li><a href="#headline-69">Constructor</a>
</li>
<li><a href="#headline-70">Functors</a>
</li>
<li><a href="#headline-71">Constant arguments in methods</a>
</li>
<li><a href="#headline-72">Defining member function outside the class</a>
</li>
<li><a href="#headline-73">Member initializer list</a>
</li>
<li><a href="#headline-74">Initialize members modern</a>
</li>
<li><a href="#headline-75">Operator overloading</a>
</li>
<li><a href="#headline-76">Symbolic constants within classes</a>
</li>
<li><a href="#headline-77">Class interface principles</a>
</li>
<li><a href="#headline-78">Enumerators</a>
</li>
<li><a href="#headline-79">Inheritance</a>
<ul>
<li><a href="#headline-80">Definitionss</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#headline-81">Vectors</a>
<ul>
<li><a href="#headline-82">Prologue</a>
</li>
<li><a href="#headline-83">Fixed size vector</a>
</li>
<li><a href="#headline-84">Variable number of elements</a>
</li>
<li><a href="#headline-85">Avoiding memory leak</a>
</li>
<li><a href="#headline-86">Destructor</a>
</li>
<li><a href="#headline-87"><code class="verbatim">get()</code> and <code class="verbatim">set()</code> methods</a>
</li>
<li><a href="#headline-88">Getting element&#39;s values</a>
</li>
<li><a href="#headline-89">Constructor with initializer list <code class="verbatim">{}</code></a>
</li>
<li><a href="#headline-90">Copying</a>
<ul>
<li><a href="#headline-91">Definitionss</a>
</li>
<li><a href="#headline-92">Standard copying behavior</a>
</li>
<li><a href="#headline-93">Copy constructor</a>
</li>
<li><a href="#headline-94">Copy assignments constructor</a>
</li>
<li><a href="#headline-95">Shallow and memberwise copy</a>
</li>
</ul>
</li>
<li><a href="#headline-96">Move constructor</a>
<ul>
<li><a href="#headline-97">Definitions</a>
</li>
<li><a href="#headline-98">Move constructor and assignment</a>
</li>
<li><a href="#headline-99">Move constructor importance</a>
</li>
</ul>
</li>
<li><a href="#headline-100">Default constructor</a>
</li>
<li><a href="#headline-101">Explicit constructor</a>
</li>
<li><a href="#headline-102">Access to vector elements</a>
<ul>
<li><a href="#headline-103">Motivation</a>
</li>
<li><a href="#headline-104">Member function <code class="verbatim">operator[]</code></a>
</li>
<li><a href="#headline-105">Return pointer to elements</a>
</li>
<li><a href="#headline-106">Return a reference to elements</a>
</li>
<li><a href="#headline-107"><code class="verbatim">const</code> member function</a>
</li>
</ul>
</li>
<li><a href="#headline-108">Arrays</a>
<ul>
<li><a href="#headline-109">Definition</a>
</li>
</ul>
</li>
<li><a href="#headline-110">Vector conclusion</a>
</li>
<li><a href="#headline-111">Problems still to be solved</a>
</li>
</ul>
</li>
<li><a href="#headline-112">Templates</a>
<ul>
<li><a href="#headline-113">Definitions</a>
<ul>
<li><a href="#headline-114">What is a template?</a>
</li>
<li><a href="#headline-115">What is a container?</a>
</li>
<li><a href="#headline-116">What is template instantiation?</a>
</li>
<li><a href="#headline-117">What is generic programming?</a>
</li>
<li><a href="#headline-118">What is parametric polymorphism?</a>
</li>
<li><a href="#headline-119">Why put template definition in header files?</a>
</li>
<li><a href="#headline-120">What is a concept?</a>
</li>
</ul>
</li>
<li><a href="#headline-121">Changing size</a>
</li>
<li><a href="#headline-122">Creating Templates</a>
</li>
<li><a href="#headline-123">Type as template parameters</a>
</li>
<li><a href="#headline-124">Passing function or functor as arguments</a>
</li>
</ul>
</li>
<li><a href="#headline-125">Numerics</a>
<ul>
<li><a href="#headline-126">Accumulate</a>
</li>
</ul>
</li>
<li><a href="#headline-127">Libraries</a>
<ul>
<li><a href="#headline-128">Standard library</a>
</li>
<li><a href="#headline-129">Headers and namespace</a>
</li>
<li><a href="#headline-130">External libraries</a>
<ul>
<li><a href="#headline-131">General definitions</a>
</li>
<li><a href="#headline-132">Including a library in <code class="verbatim">/usr/include/</code></a>
</li>
<li><a href="#headline-133">Including a library elsewhere</a>
</li>
</ul>
</li>
<li><a href="#headline-134">Static and dynamic libraries</a>
</li>
<li><a href="#headline-135">Using dynamic libraries</a>
</li>
</ul>
</li>
<li><a href="#headline-136">Effective and modern</a>
<ul>
<li><a href="#headline-137">Template type deduction</a>
</li>
<li><a href="#headline-138"><code class="verbatim">auto</code> type deduction (2 Meyers)</a>
<ul>
<li><a href="#headline-139">Why prefer <code class="verbatim">auto</code> to explicit type declarations?</a>
</li>
</ul>
</li>
<li><a href="#headline-140">Smart pointers</a>
<ul>
<li><a href="#headline-141">What is it smart about it?</a>
</li>
</ul>
</li>
<li><a href="#headline-142">Universal references (&amp;&amp;)</a>
<ul>
<li><a href="#headline-143">What is an universal reference?</a>
</li>
</ul>
</li>
<li><a href="#headline-144">Modern practices</a>
<ul>
<li><a href="#headline-145">Why choose <code class="verbatim">()</code> instead <code class="verbatim">{}</code> when creating objects matter? (7 Mayers)</a>
<ul>
<li><a href="#headline-146">Possible initialization operators</a>
</li>
<li><a href="#headline-147">Problems with <code class="verbatim">= {};</code> </a>
</li>
<li><a href="#headline-148">Narrowing conversion</a>
</li>
<li><a href="#headline-149">Problems with <code class="verbatim">{}</code> braced initialization</a>
</li>
</ul>
</li>
<li><a href="#headline-150">What are scoped <code class="verbatim">enums</code>?</a>
</li>
<li><a href="#headline-151">What are special function generation?</a>
</li>
<li><a href="#headline-152">Pass by value or pass by reference?</a>
</li>
</ul>
</li>
<li><a href="#headline-153">Abstract base class (ABC) or Template</a>
</li>
</ul>
</li>
<li><a href="#headline-154">Compiler</a>
<ul>
<li><a href="#headline-155">Compilation</a>
</li>
<li><a href="#headline-156">Linking</a>
</li>
<li><a href="#headline-157">Makefile</a>
</li>
<li><a href="#headline-158">Configure</a>
</li>
<li><a href="#headline-159">Make</a>
</li>
<li><a href="#headline-160">Subsequent <code class="verbatim">Make</code> calls</a>
</li>
<li><a href="#headline-161">Make usage</a>
</li>
<li><a href="#headline-162">Make install</a>
</li>
</ul>
</li>
<li><a href="#headline-163">CMake</a>
<ul>
<li><a href="#headline-164">Introduction</a>
</li>
<li><a href="#headline-165">Project setup</a>
</li>
<li><a href="#headline-166">File generator</a>
</li>
<li><a href="#headline-167">Using CMake</a>
<ul>
<li><a href="#headline-168">Basic setup</a>
</li>
<li><a href="#headline-169">Adding information to <code class="verbatim">CMakeLists.txt</code></a>
</li>
<li><a href="#headline-170">Adding multiple sources to <code class="verbatim">CMakeLists.txt</code></a>
</li>
<li><a href="#headline-171">Adding a dynamic library to <code class="verbatim">CMakeLists.txt</code></a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#headline-172">References</a>
</li>
</ul>
</nav>
      </div>
      
    </div>
    

  </main>

   

  
  <script src="/js/index.min.575dda8d49ee02639942c63564273e6da972ab531dda26a08800bdcb477cbd7f.js" integrity="sha256-V13ajUnuAmOZQsY1ZCc&#43;balyq1Md2iagiAC9y0d8vX8=" crossorigin="anonymous"></script>
  
  
  

  
  
  

  
    <script src="/js/table-of-contents.js"></script>
  


</body>

</html>
